# 算法刷题

## 连个数组求交集

首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为 什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一 致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了<元素,出现次数>。剩下 的就是顺利成章的解题。

如果两个数组是有序的，考虑使用双指针的解法。

- 设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起 向后移动，并且将相等的元素放入空白数组。
- 如果两个指针的元素不相等，我们将小的一个指针后移。如此反复

## 最长公共前缀

我们要想寻找长公共前，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。 假定我们现在就从一个数组中寻找长公共前，那么首先，我们可以将第一个元素设置为基准 元素x0。假如数组为["ﬂow","ﬂower","ﬂight"]，ﬂow就是我们的基准元素x0。

## 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的 大利润。注意你不能在买入股票前卖出股票。

```
输入: [7,1,5,3,6,4] 
输出: 7
```

> 解释： 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易 所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 

```
输入: [1,2,3,4,5] 
输出: 4
```

解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易 所能获得利润 = 5 -1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因 为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出 售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。
2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机 会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到大化。这个条件也是相当重要的， 如果我们把这里变成，多完成两笔交易，就变成另一道题。

我们要在满足1和2的条件下获取大利益，其实就是尽可能多的低价买入高价卖出。 而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出 所有的上升波段的和。

```java
public class Solution {

    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }
        // 0：持有现金
        // 1：持有股票
        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0
        int[][] dp = new int[len][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}
```

## 树

### 二叉树的最小深度

#### 题目描述

求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。

#### 代码：

```java
public class Solution {
    /**
     * 
     * @param root TreeNode类r 
     * @return int整型
     */
    public int run (TreeNode root) {
        // write code here
        if(root == null) return 0;
        if(root.left == null&&root.right == null)return 1;
        if(root.left == null){
            return run(root.right)+1;
        }
        if(root.right == null){
            return run(root.left)+1;
        }
        return Math.min(run(root.left),run(root.right))+1; 
    }
  
}
```

## 栈

### 后缀表达式求值

计算逆波兰式（后缀表达式）的值

运算符仅包含"+","-","*"和"/"，被操作数可能是整数或其他表达式

#### 代码：

```java
public class Solution {
    /**
     * 
     * @param tokens string字符串一维数组 
     * @return int整型
     */
    public int evalRPN (String[] tokens) {
        // write code here
        // 栈
        LinkedList<Integer> res = new LinkedList<>();
        //
        int l = tokens.length;
        int a = 0;
        int b = 0;
        for(int i=0; i<l; i++){
            if(tokens[i].equals("+")){
                b = res.removeFirst();
                a = res.removeFirst();
                res.addFirst(a+b);
            }else if(tokens[i].equals("-")){
                b = res.removeFirst();
                a = res.removeFirst();
                res.addFirst(a-b);
            }else if(tokens[i].equals("*")){
                b = res.removeFirst();
                a = res.removeFirst();
                res.addFirst(a*b);
            }else if(tokens[i].equals("/")){
                b = res.removeFirst();
                a = res.removeFirst();
                res.addFirst(a / b);
            }else{
                res.addFirst(Integer.parseInt(tokens[i]));
            }
        }
        return res.getFirst();
    }
}
```



### 多少个点位于同一直线

#### 题目描述

对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上

#### 代码

```java
// 主要是斜率


```

## 链表

### 链表排序

在O(n log n)的时间内使用常数级空间复杂度对链表进行排序。==(应该不使用 递归（//TODO）)==

代码：

```java
public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @return ListNode类
     */
    public ListNode sortList (ListNode head) {
        // write code here
        if(head==null || head.next == null) return head;
        ListNode frist = head, second = null;
        ListNode mid = getMid(head);
        second = mid.next;
        mid.next = null;
        frist = sortList(frist);
        second = sortList(second);
        return marge(frist,second);
    }
   
    // 合并
    public ListNode marge(ListNode frist,ListNode second){
        if(frist == null) return second;
        if(second == null) return frist;
        ListNode head = new ListNode(0);
        head.next = null;
        ListNode result = head;
        
        while(frist != null && second != null){
            if(frist.val < second.val){
                head.next = frist;
                head = head.next;
                frist = frist.next;
            }else{
                head.next = second;
                head = head.next;
                second = second.next;
            }
        }
        if(frist == null){
            head.next = second;
        }else{
            head.next = frist;
        }
        return result.next;
    }
    
    // 取中间 利用快慢指针求 中间值
    public ListNode getMid(ListNode node){
        if(node == null) return node;
        ListNode f_node = node,s_node = node.next;
        while(s_node != null && s_node.next != null){
            f_node = f_node.next;
            s_node = s_node.next.next;
        }
        return f_node;
    }
}
```

### 链表中环的入口结点

对于一个给定的链表，返回环的入口节点，如果没有环，返回null

拓展：

你能给出不利用额外空间的解法么？

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
      ListNode p = new ListNode(0);
      while(head!=null  && head.next!=null){
          // head.next==head 避免自己是环
         // 每次遍历一个结点，都改变结点的指向，指向P
        if(head.next.next == p||head.next==head){
            return head.next;
        }
        ListNode t = head;
        head = head.next;
        t.next = p;
       }
        return null;
    }
}
```

## 动态规划

### 差分词句

给定一个字符串s和一组单词dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中所有的单词都是dict中的单词（序列可以包含一个或多个单词）。

例如:
给定s=“nowcode”；
dict=["now", "code"].
返回true，因为"nowcode"可以被分割成"now code".

代码

```java
public class Solution {
    public boolean wordBreak(String s, Set<String> dict) {
        // dp[i] 代表 到第 i 个字符可以 被成功分割。
        boolean [] dp = new boolean[s.length()+1];
        dp[0] = true;
        for(int i=1; i <= s.length(); i++){
            // 判断这次分割 和 上几次的成功的分割 是否能组成
            for(int j=i-1; j>=0; j--){
                String t = s.substring(j,i);
                if(dp[j] && dict.contains(t)){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

### 斐波那契问题

$$
F(n) = F(n-1)+F(n-2)
$$

O(n) 的写法：

```java
public int f(int n){
    if(n < 1) return 0;
    if(n==1 || n==2) return 1;
    int pre = 1;// 用于记录前一个值
    int temp = 1;
    int res = 1;// 当前结果
    for(int i=3; i<=n; i++){
        temp = res;
        res = res + pre;
        pre = temp;
    }
    return res;
}
```

### 如何在 log n 的时间内求一个数的 N 次方。

```java
// 求 m 的 p 次方 ，如 2 的 5 次方
// 5 的二进制 101
// 2^5 = 2^4 * 2^1
public static int getM(int m, int p){
        int res = 1;
        int temp = 1;
        while(p != 0){
            temp = temp * m;
            if((p&1) == 1){
                res = res * temp;
            }
            p>>=1;
        }
        return res;
    }

```

### 换钱的最少货币数

```java
// arr=[5,2,3] aim = 20,最少是 4 张5元
//dp[i][j]:在可以任意使用arr[0..1]货币的情况下，组成 j 所需要的最小张数。

public static int minCoins(int [] arr, int aim){
        if (arr == null || aim < 0|| arr.length == 0) return -1;
        int n = arr.length;
        int max = Integer.MAX_VALUE;
        int [][] dp = new int [n][aim+1];
        for (int i = 1; i <= aim; i++) {
            // 默认 0 号 货币的面值无法对 i 进行兑换
            dp[0][i] = max;
            // 判断是否 能够 兑换，
            // dp[0][i - arr[0]] 是用于 判断 i-arr[0] 的钱数 是否成功兑换了，若成功在此基础 +1
            if(i >= arr[0] && dp[0][i - arr[0]] != max){
                dp[0][i] = dp[0][i - arr[0]] + 1;
            }
        }
        int left = 0;
        // 循环 代表 选取 第 i 个 货币
        for (int i = 1; i < n; i++) {
            // 和上面初始化 步骤一样
            for (int j = 1; j <= aim; j++) {
                left = max;
                if (j >= arr[i] && dp[i][j-arr[i]] != max){
                    left = dp[i][j-arr[i]] + 1;
                }
                // 和 dp[i-1][j] 比较 为了 当不选择此 货币 的情况。
                dp[i][j] = Math.min(left,dp[i-1][j]);
            }
        }
        return dp[n-1][aim] != max? dp[n-1][aim]  : -1 ;
    }
```

补充版：若 arr 中的数值 只是 代表 面值，不可以无限 获取了，也就是一个数，只去一次。

```java
public static int minCoins2(int [] arr,int aim){
    if (arr == null || arr.length == 0 || aim<0) return -1;

    int n = arr.length;
    int max = Integer.MAX_VALUE;
    int [][] dp = new int[n][aim+1];

    // 默认 第0 个元素无法 兑换
    for (int i = 1; i <= aim; i++) dp[0][i] = max;
    // 由于 一个货币 只能使用一次
    if (arr[0] <= aim) dp[0][arr[0]] = 1;

    int leftup = 0; // 从左上角某个位置开始

    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= aim; j++) {
            leftup = max;
            // 因为货币职能取一次。
            // j - arr[i]>= 0 代表 可以进行取了。
            // dp[i-1][j-arr[i]] 
            if (j-arr[i] >= 0 && dp[i-1][j-arr[i]] != max){
                leftup = dp[i-1][j-arr[i]] + 1;
            }
            dp[i][j] = Math.min(leftup,dp[i-1][j]);
        }
    }

    return dp[n-1][aim] != max ? dp[n-1][aim] :-1;
}
```

