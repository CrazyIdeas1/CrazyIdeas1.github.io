# 算法刷题

## 连个数组求交集

首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为 什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一 致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了<元素,出现次数>。剩下 的就是顺利成章的解题。

如果两个数组是有序的，考虑使用双指针的解法。

- 设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起 向后移动，并且将相等的元素放入空白数组。
- 如果两个指针的元素不相等，我们将小的一个指针后移。如此反复

## 最长公共前缀

我们要想寻找长公共前，那么首先这个前缀是公共的，我们可以从任意一个元素中找到它。 假定我们现在就从一个数组中寻找长公共前，那么首先，我们可以将第一个元素设置为基准 元素x0。假如数组为["ﬂow","ﬂower","ﬂight"]，ﬂow就是我们的基准元素x0。

## 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的 大利润。注意你不能在买入股票前卖出股票。

```
输入: [7,1,5,3,6,4] 
输出: 7
```

> 解释： 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易 所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 

```
输入: [1,2,3,4,5] 
输出: 4
```

解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易 所能获得利润 = 5 -1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因 为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

1、不能参与多笔交易。换句话讲，我们只能在手上没有股票的时候买入，也就是必须在再次购买前出 售掉之前的股票。像我们平时买股票时的追涨杀跌是不可以的。
2、尽可能地多进行交易。这个非常好理解。像是黄金，一年基本上都有2-3次涨跌。我们只要把握住机 会，在每一次涨跌的时候，低价卖入高价卖出，就可以使利益达到大化。这个条件也是相当重要的， 如果我们把这里变成，多完成两笔交易，就变成另一道题。

我们要在满足1和2的条件下获取大利益，其实就是尽可能多的低价买入高价卖出。 而每一次上升波段，其实就是一次低价买入高价卖出。而我们没有限制交易次数，也就是我们需要求出 所有的上升波段的和。

```java
public class Solution {

    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }
        // 0：持有现金
        // 1：持有股票
        // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0
        int[][] dp = new int[len][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < len; i++) {
            // 这两行调换顺序也是可以的
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}
```

