# Java基础

## 基础知识点

###  1. 接口与抽象类区别 

都不能实例化

接口：所有的方法都是抽象的 public 方法，允许多继承。JDK1.8 可以实现默认方法和静态方法，通过 default 和 static 关键字。

抽象类：只能单继承，里面可以有非抽象方法，允许 private 和 protected 修饰方法。

### 内存溢出是怎么回事？举个例子。

 内存溢出(out of memory)，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。

内存泄漏（memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存,迟早会被占光。 

 内存溢出可能的原因:

- 程序中存在死循环
- 静态变量和静态方法太多了
- 内存泄露
- 大对象过多
- 空间给的太小

###  Java有自己的内存回收机制，但为什么还存在内存泄漏的问题呢？ 

### ==和equals的区别

- `==`是运算符，而`equals`是Object的基本⽅方法，
- `==`用于基本类型的数据的比较，或者是比较两个对象的引用是否相同，
- equals用于比较两个对象的值是否相等，例如字符串的比较。 

### hashCode方法的作用

- hashCode是用来在散列存储结构中确定对象的存储地址的；
- 如果两个对象的 equals 相等，那么他们的hashcode值一定要相等。
- 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法

###  hash冲突：

两个或两个以上 的值hash计算的结果有相同的，造成冲突。

解决办法：

1. 开放地址法：插入元素时，如果发生冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下一个空 槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。
2. 链地址法：现行探测法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针 存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。
3. 再散列(双/多重散列)：当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增 加。
4. 建立一个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量量 OverTable[0..v]⽤用以存储发⽣生冲突的记录。

### 一致性hash：

1. 分布式系统中常用算法。设计目的是为了解决因特网中的热点(hot spot)问题。解决了P2P环境最为关键问题—如何在动态网络拓扑中分布存储和路由；
2. 一致性hash算法引入虚拟节点机制，解决服务节点少时数据倾斜问题(即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。)

在 memcached 中，用于进行数据存储结点的选择。

一致性hash算法是对我们要存储数据的服务器进行hash计算，进而确认每个key的存储位置。

选择具体的机器节点不在只依赖需要缓存数据的key的hash本身了，而是机器节点本身也进行了hash运算。 

具体做法：如果有一个写入缓存的请求，其中Key值为K，计算器hash值Hash(K)， Hash(K) 对应于环中的某一个点，如果该点对应没有映射到具体的某一个机器器节点，那么顺时针查找，直到第一次找到有映射机器的节点，该节点就是确定的目标节点，如果超过了 2^32仍然找不到节点，则命中第一个机器器节点。比如 Hash(K) 的值介于A~B之间，那么命中的机器节点应该是B节点 

### NIO、BIO、AIO

- BIO：阻塞式，线程池初始时创建一定量线程，超过则等待；
- NIO：非阻塞式，不同线程池干专业的事，提高吐出量
- AIO：异步处理，让少量线程做大量的事。

#### io多路复用

###  java中⼀一个字符占多少个字节？int，long，double占多少个字节？ 

- 1字节： byte , boolean 
- 2字节： short , char 
- 4字节： int , float 
- 8字节： long , double 

### final/finaly/finalize区别？

- final是定义类、⽅方法、字段的修饰符，表示类不不可被继承，⽅方法不不能被重写，字段值不不能被修改 
  - 声明变量时直接赋值，也可以在构造函数中复制
  - 若是 static final 那么就是 只能在申明时 赋值。
- finally是异常处理理机制的关键字，表示后执⾏行行
- finalize是Object的⼀一个⽅方法，在对象被虚拟机回收时会判断是否执⾏行行该⽅方法，当对象没有覆盖finalize⽅方法，或者finalize⽅方法 已经被虚拟机调⽤用过，虚拟机将这两种情况都视为“没有必要执⾏行行” 

### 为什么一般在public类final终态成员变量申明时要加static?   

static对象存放在静态空间，不会在运行时被释放，可以节省内存，类的多个对象同时引用只有一份,没有多份拷贝

### Session/Cookie区别？

Session存储在服务器器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串

###  String/StringBuffer/StringBuilder的区别以及实现？ 

-  String、StringBuffer是线程安全的，StringBuilder不不是 
- StringBuffer线程安全但效率低，应该使⽤用在多线程情况下；
- StringBuilder线程不不安全，在单线程情况下效率⾼高；

###  什么是java序列列化，如何实现java序列列化（写⼀一个例例⼦子） 

序列列化作用：对象保存(保存为一组字节，只保存对象的成员变量)；当使用RMI(远程方法调用)，或者在网络中传递对象 时，都会使⽤用对象序列列化；

原理理：将对象写⼊入流中,再从流中还原.ObjectOutPutStream 

对象中的成员对象也是可序列列化的,但可通过transient关键字标示不不序列列化 

通过序列列化进⾏行行深拷⻉贝,从流中还原对象 

serialVersionUID 主要是解决序列列化后与再反序列列化时有修改的不不兼容问题. 

###  静态对象

1. 在main⽅方法开始运⾏行行时需要注意static的先后顺序：静态变量量和静态代码块(按代码先后顺序)—-匿匿名块和成员变量量(按代码先 后顺序)—-构造函数—静态⽅方法(调⽤用时加载)
2. 先执⾏行行⽗父类的静态块,再执⾏行行⼦子类的静态块,再执⾏行行⽗父类的构造⽅方法,再执⾏行行⼦子类的构造⽅方法 1、静态块>构造⽅方法； 2、⽗父>⼦子

###  多态：

父类或接口引用指向子类或者实现该接口的类的对象。是运行时行为，不是编译时行为。

条件：有继承、有重写、要父类引用指向子类对象。

### 幂等处理：

[幂等](https://www.jianshu.com/p/cea3675a590b)：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的

- 查询操作是天然幂等
- 唯⼀一索引，防⽌止新增脏数据 
- token机制，防⽌止⻚页⾯面重复提交
- 悲观锁  for update 
- 乐观锁（通过版本号/时间戳实现， 通过条件限制where avai_amount-#subAmount# >= 0）
- 分布式锁 

















## 集合

### 常⽤用的集合类有哪些？⽐比如list如何排序？ 

主要分为三类，Map、Set、List 

- Map: HashMap、LinkedHashMap、TreeMap 
- Set：HashSet、LinkedHashSet、TreeSet 
- List: ArrayList、LinkedList 

```java
Collections.sort(list); // list 排序
```

### ArrayList和LinkedList内部实现大致是怎样的？他们之间的区别和优缺点？ 

ArrayList：是基于数组的存储结构，查找快，添加和删除比较慢，默认大小为 10，扩容是1.5倍，利用数组的复制。

LinkedList：是基于双向链表的存储接口，查找慢，添加和删除有优势，

### Hashmap实现原理理？如何保证HashMap线程安全

hashmap采用的是数组加链表（JDK7），采用数组加链表加红黑树（JDK8）

允许有空值，

![](D:\harlearn.github.io\图片\hashMap的put操作.PNG)

1. Jdk1.8以前是进⾏行行**四次扰动计算**，可能从速度功效各⽅方⾯面考虑，jdk1.8变成扰动⼀**一次**，低16位和⾼高16位进⾏行行异或计算。**取模的时** 候考虑取模运算的速度⽐比较慢，改⽤用**与操作优化效率**，很巧妙，hash table就没设计的这么好。 
2. JDK1.8⾥里里对hashmap⼤大的改变是引⼊入了了红⿊黑树，这⼀一点在hash不不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮非 常⼤大。Hashmap的底层实现是使⽤用⼀一个entry数组存储，默认**初始⼤大⼩小16**，不不过jdk8换了了名字叫node，可能是因为引⼊入了了树，叫 node更更合适吧，Node⾥里里有next引⽤用指向下⼀一个节点，因为hashmap解决冲突的思路路是**拉链法。** 
3. 另外变化⽐比较⼤大的还有扩容机制，也就是resize⽅方法

###  jdk1.8中ConcurrentHashMap size⼤大于8时会转化成红⿊黑树，请问有什什么作⽤用，如果通过remove操作，size⼩小于8了了，会发⽣生什什 么？ 

put时如果链表size>=8并且table.length>=64，这时链表会转变成⼀一个红⿊黑树，但是remove不不会逆转。

### HashMap与HashTable的区别：

HashMap 不是线程安全的，Hashtable 是线程安全的

在单线程的情况下 HashMap 效率更加的高

### 迭代器是做什么的？迭代器的fail-fast机制了解吗？主要为了解决什么问题？

### CopyOnWriteArrayList

核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。

- CopyOnWriteArrayList 相对于 ArrayList 线程安全，底层通过复制数组的方式来实现
- 在遍历使用时不会抛出 ConcurrentmodificationException 并且便利的时候就不用额外加锁
- 元素可以为 null

#### 缺点：

- 不能保证 数据实时一致性。
- 因为需要 copy 所以会造成内存占用率 比较高。











## 多线程

### 1. 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执 行？ 

无非就是在t2线程里面申明t1.join(),在t3线程里面t2.join();这样就可以了

```java
public class threadDemo7 {
	public static void main(String[] args) throws InterruptedException {
		xiancheng1 x1=new xiancheng1();
		xiancheng2 x2=new xiancheng2();
		xiancheng3 x3=new xiancheng3();
		Thread thread1 = new Thread(x1);
		thread1.start();
		Thread thread2 = new Thread(x2);
		thread1.join(); 
		thread2.start();
		Thread thread3 = new Thread(x3);
		thread2.join();
		thread3.start();
	}
}
```

或者

```java

public class Demo2 {

    private static volatile  int nextPrintWho = 1;

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException {
        ReentrantLock lock = new ReentrantLock();
        Condition conditionA = lock.newCondition();
        Condition conditionB = lock.newCondition();
        Condition conditionC = lock.newCondition();

        Runnable runnableA = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 1) {
                try {
                    conditionA.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 2;
            println(Thread.currentThread().getName());
            try {
                conditionB.signal();// 通知 B
             }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        Runnable runnableB = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 2) {
                try {
                    conditionB.await();// B等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 3;
            println(Thread.currentThread().getName());
            try {
                conditionC.signal(); // 通知C
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };


        Runnable runnableC = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 3) {
                try {
                    conditionC.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 1;
            println(Thread.currentThread().getName());
            try {
                conditionA.signal();// 通知A
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        for(int i=0; i<5; i++) {
            new Thread(runnableA,"A").start();
            new Thread(runnableB,"B").start();
            new Thread(runnableC,"C").start();
        }


    }

    private static void println(Object object) {
        System.out.println(object);
    }

}
```

### 2. 在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允 许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？ 

lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写 像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。

### 3. 在 java 中 wait 和 sleep 方法的不同？ 

最大的不同是在等待时 wait 会释放 锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。 

###  4. 用 Java 实现阻塞队列。

如果他用 wait()和 notify()方法来实现阻塞队列，

### 5. 用 Java 写代码来解决生产者——消费者问题。 

用阻塞队列实现 的方法

### 6. 用 Java 编程一个会导致死锁的程序，你将怎么解决？ 

- 银行家算法：避免死锁
- 消进程法：解除死锁
- 资源静态分配法：预防死锁
- 资源分配图简化法：检测死锁

### 7.什么是原子操作，Java 中的原子操作是什么

### Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什 么不同？

### 你将如何使用 threaddump？你将如何分析 Thread dump

在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志

### 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法

当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。 但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码

### Java 中你怎样唤醒一个阻塞的线程？ 

如果线程遇到了 IO 阻塞，我并 且不认为有一种方法可以中止线程。如果线程因为调用 wait()、sleep()、或者 join()方法而 导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。

### 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？ 

### 什么是不可变对象，它对写并发应用有什么帮助

这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变 的。 

### 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？ 

多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题 是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于 实际应用的 Java 线程问题。 

### 进程之间通信

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。

IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。

- 管道：
  - 无名管道：半双工，具有亲缘关系的进程之间的通信
  - 命名管道：可以在无关进程之间交换数据。
- 消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
  - 消息队列是面向记录的，其中的消息具**有特定的格式以及特定的优先级**。
  - 消息队列**独立**于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
  - 消息队列可以**实现消息的随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。
- 信号量：它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
  - 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
  - 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
  - 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
  - 支持信号量组。
- 共享存储：共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
  - 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
  - 因为多个进程可以同时操作，所以需要进行同步。
  - 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
- Socket：套字节
- Streams：

### 并发，执行时间与线程池的选择



### 悲观锁乐观锁，多线程竞争激烈选用哪种？为啥？



## 反射

### 反射原理

反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类

### java反射机制

可以在运行时判断一个对象所属的类，构造一个类的对象，判断类具有的成员变量和方法，调用1个对象的方法。 

4个关键的类：Class，Constructor，Field，Method。    

- getConstructor获得构造函数/getDeclardConstructor； 
- getField/getFields/getDeclardFields获得类所⽣生命的所有字段；
- getMethod/getMethods/getDeclardMethod获得类声明的所有⽅方法，

正常方法是一个类创建对象，而反射是1个对象找到1个类。 

### 获得Class对象的方式 

1. 静态类的.class语法：GuideUtil.class 
2. 普通类对象的getClass()⽅方法：new Test().getClass() 
3. 通过Class对象的forName()⽅方法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil"); 
4. 对于包装类,可以通过.TYPE语法⽅方式：Integer.TYPE 

## Jvm

###  jvm内存结构？为什什么需要GC？ 

- 方法区：类型的常量池，字段，方法信息，方法字节码。
- 堆：应用系统的对象
- 程序计数器：记录代码执行的位置
- 虚拟机栈：栈帧，保存一个方法的局部变量，操作数，常量池指针
- 本地方法栈：和 虚拟机栈类似，针对的 Native 修饰的方法

垃圾回收：垃圾回收可以有效的防⽌止内存泄漏漏，有效的使⽤用可以使⽤用的内存

### jvm内存模型：

- 每⼀一个线程有⼀一个⼯工作内存，和主存独⽴立；
- ⼯工作内存存放主存中变量量的值的拷⻉贝；
- 对于普通变量量，⼀一个线程中更更新的值，不不能⻢马上反应在其他变量量中；如果需要在其他线程中⽴立即可⻅见，需要使⽤用volatile关键字； 

**可⻅见性：**⼀一个线程修改了了变量量，其他线程可以⽴立即知道。

- volatile； 
- synchronized（unlock之前，写变量量值回主存）；
- final（⼀一旦初始化完成，其他线程可⻅见）。 

### java四引⽤用：

强引用：在什么情况下，都不会被垃圾收集器回收。

软引用：在内存不够时，会被回收

弱引用：在每一次垃圾回收时，就会被回收掉

虚引用：任何情况都有可能被垃圾收集器回收，用来跟踪对象被垃圾收集器回收的活动，会给系统一个通知

### GC算法分类

**标记清除：**

先标记需要被清除的对象，然后统一清除所有被清除的对象。

缺点：有大量被清除对象时，效率低。内存碎片化严重

**标记复制：**

将内存分为两块，只使用其中一块，每次将存活的对象复制到未使用的那一块内存中，清除所有已经使用的内存。

缺点：当存活对象较高时，效率低。

**标记整理：**

先标记，然后将存活对象复制到内存的一端，然后，清除边界外所有的空间。

适合用户存活对象多的场景。

优点：解决了碎片化问题。结局了存活率高时，复制算法效率低的问题。

**分代算法：**

大部分对象都是朝生夕灭的

经历越多次的垃圾回收，月不容易被回收。

标记整理算法适合老年代，标记复制算法适合新生代。

### MinorGC & FullGC

1. Minor GC通常发⽣生在新⽣生代的Eden区，在这个区的对象⽣生存期短，往往发⽣生GC的频率较⾼高，回收速度⽐比较快，⼀一般采⽤用复制-回 收算法
2. Full GC/Major GC 发⽣生在⽼老老年年代，⼀一般情况下，触发⽼老老年年代GC的时候不不会触发Minor GC，所采⽤用的是标记-清除算法。 

### 垃圾收集器器：

- CMS收集器器，基于标记清理理；
- G1收集器器(JDK)：整体上是基于标记清理理，局部采⽤用复制； 

综上：新⽣生代基本采⽤用复制算法，⽼老老年年代采⽤用标记整理理算法。cms采⽤用标记清理理

### 哪些情况下对象会进入老年代？

- 当达到年龄阈值（默认为15岁）会直接进入老年代
- 大对象直接进入老年代； 
- 需要老年代进行分配担保，让survivor无法容纳的对象直接进入老年代； 
- 如果在Survivor空间中相同年年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入年老 代。 

###  java堆溢出（heap）：

-  Java堆内存主要⽤用来存放运⾏行行过程中所以的对象，该区域OOM异常⼀一般会有如下错误信息： OutofMemoryError
- 此类错误⼀一般通过Eclipse Memory Analyzer分析OOM时dump的内存快照就能分析出来，到底是由于程序原因导致的内存泄 露露，还是由于没有估计好JVM内存的⼤大⼩小⽽而导致的内存溢出。 

### 栈溢出（stack）：

- 栈⽤用来存储线程的局部变量量表、操作数栈、动态链接、⽅方法出⼝口等信息。如果请求栈的深度不不⾜足时抛出的错误会包含类似下⾯面 的信息： java.lang.StackOverflowError。
-  另外，由于每个线程占的内存⼤大概为1M，因此线程的创建也需要内存空间。
-  可能原因
  -  递归：递归⾥里里⽤用到的局部变量量存储在堆栈中，堆栈的访问效率⾼高，速度快，但空间有限，递归太多变量量需要⼀一直⼊入栈⽽而 不不出栈，导致需要的内存空间⼤大于堆栈的空间，栈空间是2M，堆空间内存空间。 

###  对象流转流程（新⽣生代复制算法，可以减少内存碎⽚片）：

- 对象A被new出来之后，是被存放在Eden（伊甸园）区的。 
- 当发⽣生⼀一次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。 
-  GC会清空Eden和s0中存储的所有对象； 
- 交换s0和s1的⻆角⾊色；
- 重复上⾯面的步骤。





### java类加载机制：

将字节码文件加载到内存中

过程：

- 加载：根据全限定名加载二进制流，将静态存储结构转化为方法区运行时数据结构，并生成以改变此类的 Class 对象。
- 验证：验证 文件验证，元数据验证，字节码验证，符号引用验证
- 准备：为类属性分配内存，并设置类属性的初始值，（Static 会被设置默认值，static final 被设置为给予的值）
- 解析：将常量池中的符号引用替换成直接引用。
- 初始化：初始化阶段，就是执行类构造器 `<clint>()` 方法的过程。
- 使用：
- 卸载：

### 类加载器：

- BootStrap（启动类加载器），最顶层的类加载器，主要加载 jdk 核心库lib下面
- Extension（扩展类加载器），用于加载lib/ext目录下面的jar 包
- application（应用程序加载器），加载 classpath 的所有类。
- 自定义类加载器

### 双亲委派机制：

当⼀一个ClassLoader实例例需要加载某个类时，它会试图亲⾃自搜索某个类之前，先把这个任务委托给它的⽗父类加载器器，这 个过程是由上⾄至下依次检查的，⾸首先由顶层的类加载器器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给 Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进⾏行行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂文件系统或⽹网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出 ClassNotFoundException异常。

作用：避免重复加载；考虑安全因素，避免自定义的类去替代系统类，如String。

### jvm如何判定两个class是否相同

JVM在判定两个class是否相同时，不不仅要判断两个类名是否相同，⽽而且要判断是否由同⼀一个类加 载器器实例例加载的。只有两者同时满⾜足的情况下，JVM才认为这两个class是相同的。 

1. ⾃底向上检查类是否已经加载； 2. ⾃顶向下尝试加载类。

### 自定义类加载器

- 继承 ClassLoader
- 重写 父类的 findClass 方法

### 引起类加载的五个行为： 

- 遇到 new、putstatic、getstatic、invokestatic 这四条字节码指令。
- 反射调用时，
- 子类初始时，发现父类没有初始化，会触发父类的加载
- 主类，含有main的
- jdk7的动态语言支持

### java对象创建的时机，几种方式创建对象

- 使用反射
- clone
- 序列化
- new

### jvm 调优

#### 什么时间进行jvm 调优

1. 内存（老年代）持续上涨达到设置的最大内存值
2. Full GC 次数频率过高
3. GC 停顿时间过长。
4. 出现内存溢出
5. 应用中使用本地缓存且占用大量内存空间
6. 系统吞吐量与响应性能不高或下降

#### 调优原则：

先检查引用代码，其次考虑优化 JVM

- 减少创建对象的数量
- 减少全局变量和大对象

####  调优步骤

- 分析GC⽇日志及dump⽂文件，判断是否需要优化，确定瓶颈问题点； 
- 确定jvm调优量量化⽬目标； 
-  确定jvm调优参数（根据历史jvm参数来调整）；
-  调优⼀一台服务器器，对⽐比观察调优前后的差异； 
- 不不断的分析和调整，知道找到合适的jvm参数配置；
-  找到合适的参数，将这些参数应⽤用到所有服务器器，并进⾏行行后续跟踪。 



















# 数据库

## MySQL

## 引擎相关的的一些问题？

### 你了解MySQL的那些引擎？

MySQL的引擎比较多，我比较熟悉的是 InnoDB 和 MyISAM 两个引擎。

### 你介绍一下这两个引擎区别，以及在什么场景下使用哪种引擎？

- InnoDB 是支持事务，外键，行锁的，而MyISAM是不支持的，只支持表级锁。
- InnoDB的数据和索引是放在表空间里面，而MyISAM的数据和索引是分开存储的，会对表进行压缩。

MyISAM 适合 读多写少的场景，并且对事务要求低。不适合高并发。

InnoDB 适合 读少写多的场景，高并发的场景。

### 事务的特性是什么？

原子性：事务要么成功，要么失败。（靠 undo log 保证）

一致性：事务结束之前和结束之后，总的结果没有变化。数据库总是从一个一致状态转换到另一个一致性的状态。（undo log + redo log）

隔离性：多个事务之间，不相互干扰。(靠 锁 来保证事务的隔离性)

持久性：事务一旦完成就是持久性的。（redo log保证事务的持久性）

### 事务的隔离级别：

读未提交：一个事务可以读取另一个事务，未提交的内容。会产生脏读，不可重复读，幻读问题。

读已提交：一个事务可以读取另一个事务已经提交的内容。解决了脏读的问题，但是会产生不可重复读，幻读的问题。

可重复读：保证了同一个事务中多次读取同样记录的结果是一致的。但是还是会产生 幻读问题。

序列化：强制事务串行执行，会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争的问题。

### 了解MVCC吗？

MVCC 是多版本控制器，可以把它理解成`行级锁`的变种，在很多情况下可以避免加锁，因此开销更低。

MVCC 是通过保存某个时间点的`快照`来实现的，也就是说不管需要执行多长时间，每个事务看到的数据都是一致的。

### InnoDB 的MVCC的工作方式：

通过在每行记录后面保存两个隐藏的列来实现的，一个保存行的创建时间，一个保存行的过期时间(或删除时间)，里面保存的都是系统版本号。

每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务版本号，用来和查询到的每行记录的版本号进行比较。

- select
  - 第一，InnoDB只查找版本`早于`当前事务版本的数据行，可以保证数据行要么在事务开始前已经存在，要么就是事务自身插入或修改过的。
  - 第二，行的删除版本号，要么是未定义的，要么是大于当前事务的版本号。这样可以保证 数据行在事务开始之前没有被删除。
- insert
  - 为新插入的每一行保存当前系统版本号作为行版本号
- delete
  - 为删除的每一行保存当前系统版本号作为行删除标识。
- update
  - InnoDB 为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行的删除标识。

### B树，B+树，AVL，红黑树的对比

B树 和 B+ 树都是平衡的多分树

B树定义

- 根节点至少有两个子节点。
- 每个节点有M-1个key，并且以升序排列（每个非叶子节点由M-1个key和M个指针组成）
- 位于两个key之间的子节点，它的值也位于两个key对应的值之间。
- 除叶子结点，其它节点至少有M/2个子节点

B+ 树是对B树的一种变形树，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码；
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

红黑树，逻辑上很近的结点，物理上可能很远，无法利用局部操作，io差

### InnoDB 和 MyISAM 的索引？

InnoDB 和 MyISAM 引擎的索引都是采用 B+ 树结构。但是

InnoDB 采用的的聚集索引，索引和数据存储在一起。是通过主键索引来构建 B+ 树 的，叶子结点存储的是真实的数据，但是辅助索引叶子结点存储的是 数据的主键。

MyISAM 是非聚集索引，索引和数据分开存储，叶子结点存储的是 数据的地址，主索引和辅助索引没有区别。

### 主键和候选键有什么区别？ 

表格的每一行都由主键唯一标识,一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

## SQL 优化相关

### 数据库性能的优化：

- 选择合适的数据库引擎，合理使用索引
- 分页获取数据，只获得需要的字段（也就是使用 limit 分页获取数据，不要使用 select * ）
- 优化业务逻辑，减少数据库IO
- 分库分表
- 部署主从数据库
- 升级硬件

### 索引的使用和优化

- 最左前缀原理与相关优化:

最左前缀一般应用在 `联合索引` 上。联合索引：是索引 以一定顺序引用多个列，一个联合索引是一个有序元组<a1, a2, …, an>，其中各个元素均为数据表的一列。最左前缀的几种情况：

- 全列匹配：索引的每一列都可以匹配，理论上顺序不可以变化，但是 mysql 查询优化器自动优化条件顺序。
- 最左前缀：当查询条件精确匹配索引的左边连续一个或几个列时，只能用到一部分，即条件所组成的最左前缀。
- 中间索引未提供：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。
- 没有第一个索引：查询条件没有指定索引第一列。不会走索引。
- 匹配某列的前缀字符串。（如果通配符%不出现在开头，则可以用到索引）。
- 范围查询：范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。
- 查询条件中含有函数或表达式。（如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引）

索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

- 表记录比较少
- 索引的选择性比较低时，不建议使用索引。比如：性别
  - 选择性的计算方式：不重复索引值 除以 表记录的数量。
- 和选择性有关的一个优化就是 前缀优化，截取索引的一部分，这样既可以 保证较高的 选择性的前提下，存储空间最小。但是**其缺点**是不能用于`ORDER BY`和`GROUP BY`操作。

### 什么情况下不走索引？

- **select *** 可能导致不走索引；
- **空值**会导致不⾛索引，因为hashset不能存空值； 
- 索引列**有函数运算**，不走索引，可以在索引列建立一个函数的索引。 
- **隐式转换**可能导致不走索引；
- **!= 或者<>**可能导致不走索引；
- like '%liu' **百分号在前**不走索引；
- **not in, not exist**不走索引；















---





#### InnoDB：

1. 支持事务处理
2. 支持外键
3. 支持行锁
4. 不支持FULLTEXT类型的索引（在Mysql5.6已入） 
5. 不保存表的具体行数，扫描表来计算有多少行 
6. 对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引
7. DELETE 表时，是一行一行的删除 
8. InnoDB 把数据和索引存放在表空间⾥⾯
9. 跨平台可直接拷贝使用

#### MyISAM：

1. 不支持事务
2. 表级锁
3. 不支持外键
4. 不支持 mvcc
5. 支持全文索引
6. 保存了表的具体行数
7. delete时， 先 drop 表，然后重建表
8. 表格可以被压缩

 选择：

如果系统读多，写少。对原子性要求低。那么MyISAM最好 的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。

如果系统读少，写多的时候，尤其是并发写入高的时候。 InnoDB就是首选了。

### innodb引擎的4大特性 

- 插入缓冲（insert buffer)
- 二次写(double write)
- 自适应哈希索引(ahi)
- 预读 (read ahead) 

### 行锁，表锁；乐观锁，悲观锁

乐观锁：具体实现是给表增加一个版本号的字 段，在执行update操作时比较该版本号是否与当前数据库中版本号一致，如一致，更新数据，反之拒绝。 

数据库锁机制可分为多种粒度的： 数据库，表，⻚面，行，粒度越大并发处理能力就越差。

### MySQL主备同步的基本原理理。 

1. master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）；
2. slave将master的binary log events拷贝到它的中继日志(relay log)； 
3. slave重做中继日志中的事件，将改变反映它自己的数据。

###  select * from table t where size > 10 group by size order by size的sql语句句执⾏行行顺序？ 

sql语句执行行顺序如下： where -> group by -> having -> select -> orderby

### 有多少种日志；

- 错误日志：记录出错信息，也记录一些警告信息或者正确的信息。 
- 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。 
- 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。 
- 二进制日志：记录对数据库执行更改的所有操作。 
- 中继日志：中继日志也是二进制日志，用来给slave 库恢复 
- 事务日志：重做日志redo和回滚日志undo 

### Heap表是什么？ 

HEAP表存在于内存中，用于临时高速存储。

- BLOB或TEXT字段是不允许的
- 只能使用比较运算符=，<，>，=>，= < 
- HEAP表不支持AUTO_INCREMENT
- 索引不可为NULL

### 如何控制HEAP表的最大尺寸？

Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

### 在 Mysql中ENUM的用法是什么？ 

ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。 Create table size(name ENUM('Smail,'Medium','Large');

### CHAR和VARCHAR的区别？

- char 是定长的
- varchar 是变长的
- varchar(50)中50的涵义 
  - 多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排 序时会消耗更多内存，因为order by col采用fixed_length计算col长度 
- int（20）中20的涵义 
  - 是指显示字符的长度 但要加参数的，大为255，比如它是记录行数的id,插入10笔资料，它就显示 00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如 果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0 20表示大显示宽度为20，但仍占4字节存储，存储范围不变； 

### myisamchk是用来做什么的

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### 列设置为 AUTO_INCREMENT时，如果在表中达到最大 值，会发生什么情况？ 

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

### 怎样才能找出最后一次插入时分配了哪个自动增量

LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。

### 你怎么看到为表格定义的所有索引？ 

`SHOW INDEX FROM <tablename>;`

### 可以使用多少列创建索引？ 

任何标准表最多可以创建16个索引列。

### Mysql表中允许有多少个TRIGGERS？ 

- BEFORE INSERT 
- AFTER INSERT
- BEFORE UPDATE 
- AFTER UPDATE
- BEFORE DELETE 
- AFTER DELETE

### mysql里记录货币用什么字段类型好 ?

- DECIMAL(9,2) ，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用 于存储小数点后的位数。 

### SQL优化

#### mysql调优：

- 当只要一条数据时使用 `limit 1`；
- 尽量都要走索引
- delete 和 insert 会锁表

#### 索引使用策略及优化

[原文](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

##### 最左前缀原理与相关优化

根据联合索引进行的优化，

情况一 全列匹配

当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。

情况二 最左前缀匹配。

当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。

情况三，查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。

此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。

情况四：查询条件没有指定索引第一列。

由于不是最左前缀，索引这样的查询显然用不到索引。

情况五：匹配某列的前缀字符串。

```sql
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title LIKE 'Senior%';
```

如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）

情况六：范围查询。

范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。

情况七：查询条件中含有函数或表达式。

很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引

##### 索引选择性与前缀索引

索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

- 表记录比较少
- 索引的选择性较低，也就是值是大量重复的，如性别。
  - 所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值

前缀索引：与索引选择性有关的索引优化策略，用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。

前缀索引兼顾索引大小和查询速度，但是**其缺点**是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。

##### InnoDB的主键选择与插入优化

在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。



### innodb如何实现mysql的事务？

redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。

1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。

mysql脏页：
当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页；
内存数据写入磁盘后，内存页上的数据和磁盘页上的数据就一致了，我们称这个内存页为干净页。

[原文](https://www.jb51.net/article/171617.htm)

- redo log重做日志用来保证事务的持久性
  - 
- undo log回滚日志保证事务的原子性
- undo log+redo log保证事务的一致性
- 锁（共享、排他）用来保证事务的隔离性

InnoDB有三种行锁的算法

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，而非记录本身
- Next-Key Lock：结合Gap Lock和Record Lock，锁定一个范围，并且锁定记录本身。主要解决的问题是REPEATABLE READ隔离级别下的幻读。

如果走唯一索引，那么Next-Key Lock会降级为Record Lock，即仅锁住索引本身，而不是范围。也就是说Next-Key Lock前置条件为事务隔离级别为RR且查询的索引走的非唯一索引、主键索引。



### 间隙锁

间隙锁（Gap Lock）是Innodb在可重复度的提交下为了解决幻读问题时引入的锁机制。幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的

加锁规则有以下特性：

1. 加锁的基本单位是（next-key lock）,他是前开后闭原则
2. 插叙过程中访问的对象会增加锁
3. 索引上的等值查询--给唯一索引加锁的时候，next-key lock升级为行锁
4. 索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
5. 唯一索引上的范围查询会访问到不满足条件的第一个值为止

### 意向锁

意向锁的主要用途是为了表达某个事务正在锁定一行或者将要锁定一行数据。

事务A要对一行记录r进行上X锁，那么InnoDB会先申请表的IX锁，再锁定记录r的X锁。在事务A完成之前，事务B想要来个全表操作，此时直接在表级别的IX就告诉事务B需要等待而不需要在表上判断每一行是否有锁。意向排它锁存在的价值在于节约InnoDB对于锁的定位和处理性能。另外注意了，除了全表扫描以外意向锁都不会阻塞。

### 数据库中有哪些索引类型

- 唯一索引
- 主键
- 普通索引
- 组合索引



### 怎么对一条查询语句进行调优

### 主键索引和非主键索引的区别

非主键索引的叶子节点存放的是**主键的值**，而主键索引的叶子节点存放的是**整行数据**，其中非主键索引也被称为**二级索引**，而主键索引也被称为**聚簇索引**。

#### 看看他们在查询上有什么区别

1、如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。

2、如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为**回表**。

### 聚集索引和非聚集索引的区别

### MySQL四种隔离引擎，底层实现

### 数据库的三大范式

- 列不可再分，保证原子
- 表中每一列都和主键相关联，解决部分依赖问题
- 每一列数据都和主键直接相关而不是间接相关，解决传递依赖

### 数据库如何解决幻读  (mvcc + 间隙锁)

### MySQL数据库cpu飙升到500%的话他怎么处理

- 列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化 的(干掉) 
- 查看超时日志或者错误日志（做了几年开发,一般会是查询以及大批 量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次 被坑经历)）

### SQL 注入

SQL注入主要是 针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库。

最容易被SQL注入的方式就是，程序员在编写 SQL 语句时，使用的是拼接字符串的方式。

如何预防SQL 注入呢？

- `检查变量数据类型和格式`：只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。
- `过滤特殊符号`：对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。
- `绑定变量，使用预编译语句`：绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构。

#### sql的预编译：

一条语句在最终执行时要经历三个步骤：

- 词法和语义解析
- 优化sql语句，制定执行计划
- 执行并返回结果

如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。

所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫`Prepared Statements`或者`Parameterized Statements`

预编译语句的**优势**在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入。

java 中的预编译是使用：**PrepareStatement**

mysql 命令行中的预编译：

```sql
-- 对 SQL 进行预编译
prepare ins from 'insert into t select ?,?';

-- 设计变量
set @a=999,@b='hello';
-- 执行预编译的 SQL语句。
execute ins using @a,@b;
-- 释放一条预编译语句
deallocate prepare ins;
```

mybatis 预编译的使用：

在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。

- #{} ，默认使用预编译。
- ${}，采用字符串替换的方式，方式一般用于传入数据库对象，例如传入表名。

# 网络

![img](https://uploadfiles.nowcoder.com/images/20170424/635189_1493022497861_331007FBEFE6E1C0DDDEC3AA9B6C58E2)

### http与https 的区别？

#### HTTP

- 是客户端/服务器模型
- 无状态的，每次请求完成后，不会在客户端和服务端上保存任何信息。可以通过 cookie 和 session 进行解决。
- 明文传输，数据容易被篡改：由于路由策略，HTTP数据会通过很多结点，这些结点很容易获取数据和修改数据。

#### HTTPS

HTTPS协议是由SSL+HTTP协议构建的可进行**加密传输、身份认证的网络协议**，要比http协议安全。

SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密。

https = http  + ssl/tls;

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### HTTPS的缺点

- 握手阶段 比较费时，会使页面的加载时间，延长将近50%。
- ssl 证书 是收费的。

### TCP 与 UDP 区别

#### udp

UDP 是一个无连接的面向数据报的传输层协议。不保证可靠传输，只是简单的将应用层的数据添加上报头传给IP层，没有才超时重传等功能所以速度比较快。同时首部开销小，支持一对多，一对一，多对一的通信。

#### TCP

TCP 是一个面向连接的，一对一的，可靠字节流服务。客户端和服务端在进行数据传输之前需要先建立TCP连接(此处可以提问三次握手问题)之后才能传输数据。提供 超时重发，去除重复数据，流量控制，检验数据等功能来保证数据可靠。

### TCP如何保证可靠传输的？

- 校验和：伪首部，用于计算 检验和，把首部和数据部分一起都检验。
- 超时重传： 客户端只要超过一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。
- 丢弃重复元素：可能服务端的确认迟到了，客户端已经进行了超时重传，会导致收到多个重复确认，丢弃重复元素。
- 流量控制：
  - 利用滑动窗口实现流量控制：就是让发送方的发送速率不要太快，要让接收方来得及接收。接收方返回确认时，告诉发送方，自己还可以接受的窗口大小。
  - 持续计数器： 只要TCP连接的一方收到对方的 零窗口 通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个 零窗口 探测报文段，而对方就在确认这个探测报文段时给出现在的窗口值。
- ARQ协议：也就是 滑动窗口：发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

### TCP 的 拥塞控制

**拥塞控制：**就是防止过多的数据注入到网路中，这样可以使网络中的路由器或链路不致过载。

- 慢开始：当主机发送数据时，有小到大逐渐增大拥塞窗口的数值。指数增长，达到ssthresh，就开始拥塞避免算法。
- 拥塞避免：让拥塞窗口缓慢增大，每次只增加一个，线性增长。
- 快重传： 让发送方 尽早知道发生了个别报文段的丢失。要求接收端，收到失序的报文段，立即发出对已收到的报文段的重复确认。
  - 发送方只要一连收到 3 个重复确认，就知道接收方确实没有收到报文段，就立即进行重传。
- 快恢复： 在只是丢失 个别的报文段，而不是阻塞时，不启动慢开始，而是执行快恢复算法。发送方调整门限值 ssthresh = cwnd / 2

### 三次握手和四次挥手的过程？每次发送的包的内容，客户端和服务端的状态？

#### 三次握手

![](https://img-blog.csdnimg.cn/20200818151045683.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5SWRlYXM=,size_16,color_FFFFFF,t_70#pic_center)

- 客户端向服务端发送连接请求，syn = 1,seq = x, 进入 syn_send（同步发送） 状态。
- 服务端收到请求后，发送确认报文（ack= x+1,ack=1）和同步报文(SYN = 1,seq=y)，进入 syn_rcvd
- 客户端收到服务端发送来的请求后，返回 确认报文（ack= 1，ack=y+1）进入 establish（建立）

#### 四次挥手

![](https://img-blog.csdnimg.cn/20200818153415875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5SWRlYXM=,size_16,color_FFFFFF,t_70#pic_center)

- 客户端向服务端发送 连接释放报文段（fin=1,seq=u）,进入fin_wait-1 状态
- 服务端收到客户端的 请求，返回确认报文（ack=1，seq=v,ack=u+1），进入close_wait 状态。
- 客户端收到服务端的确认报文，进入 fin_wait_2 状态。
- 服务端向 客户端发送 释放报文段（fin=1,ACK=1,seq=w,ack=u+1），进入last_ack 状态。
- 客户端收到服务端的请求，返回确认，自己进入 time_wait 状态。
- 服务端收到确认，关闭。

为什么设置 time_wait 状态：

- 保证 A 发送的最后一个 ACK 报文段能够到达 B。
- 防止 已失效的连接请求报文段。

2MSL 的等待时间 足以保证 最后一个ACK到达B，**让本连接所产生的的报文段都在网络上消失。**

## 服务端出现大量timewait是什么原因导致的？**（具体的解决方案）** 

timewait 发生在主动关闭 tcp 连接的一段，

服务端被动断开连接，并发量增加。

## ICMP协议的应用？ （ping命令和traceRoute等）

ICMP：网际控制报文协议，允许主机或路由器报告**差错情况**和提供有关**异常情况**的报告。

报文类型有两种：ICMP 差错报告报文 和 ICMP询问报文。

### ICMP 差错报告报文，有四种

- 终点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。
- 时间超时：当路由器收到生存时间为零的数据报时。
- 参数问题：当路由器或目的主机收到的数据报的首部中有的字段值不确定时，向源点发送参数问题报文。
- 改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报该发送给另外的路由器。

不应发送ICMP差错报告报文的几种情况：

- 对 ICMP 差错报告报文，不再发送 ICMP差错报告报文。
- 对第一个分片的数据报片的所有后续数据报片，都不发送
- 对具有多播地址的数据报，都不发送
- 对具有特殊地址(127.0.0.0)的数据报，不发送。

### ICMP 询问报文：有两种

- 回送请求和回答：主机向一个特定的目的主机发送询问，收到此报文的主机必须给源主机发送回答报文。
  - 用测试目的站是否可达以及了解其有关状态。
- 时间戳请求和回答：请求某台主机回答当前的时间和日期。
  - 可用于时钟同步和时间测量。利用时间超时，和 终点不可达。

### 应用

- ping：用于测试两台主机之间的联通性。使用的是 回送请求和回答。
- traceroute：用来跟踪一个分组从源点到终点的路径。

### 保活机制



## 如何实现UDP的可靠传输？ **（考虑在应用层实现，可以了解下http3.0协议）** 

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

 实现确认机制、重传机制、窗口确认机制。

UDP要想可靠，就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。

恭喜你， 你在应用层重新实现了TCP！

**HTTP3.0基于UDP的安全可靠的HTTP2.0协议。**

HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。

## https的请求过程？ **（如何建立ssl）** 

HTTPS 协议是基于ssl 的http 协议，采用端口 443，提供身份验证和加密通信。

- 对称加密：私钥加密，私钥解密
- 非对称加密：公钥加密，私钥解密

如何保证公钥传送到给正确的一方，这个时候使用了证书来验证。证书不是保证公钥的安全性，而是验证正确的交互方。

![img](https://img-blog.csdnimg.cn/20190509111404989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NldWphdmFfZXI=,size_16,color_FFFFFF,t_70)

- 对称加密，速度快，但是安全系数低。
- 非对称加密，复杂，但是安全系数高。
- 所以 先用 非对称加密的方法，将对称加密的私钥 进行加密传送。当都获得 私钥之后，在使用对称加密进行传送。

![avatar](https://img-blog.csdn.net/20171024205123701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQzMzcyNzI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

客户端请求·····》服务器发送证书（公钥）·····》客户端验证证书，并生成随机数，使用公钥进行加密发送给服务端······》服务端利用私钥解密出随机数·····》双方使用对称加密进行通信。

## 一次RPC调用的整个链路？ **（考虑三次握手负载均衡等）**



## Restful 架构

1. 每一个 URL 都代表一种资源
2. 客户端与服务器之间，传递这种资源的某种表现层。
3. 客户端通过 四个 Http动词，对服务器资源进行操作，实现 "表现层状态转化"。

## http + restful 和 RPC的区别？各自适用的场景？ 

RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。

- 由于HTTP在应用层中完成，整个通信的代价较高，
- 远程过程调用中直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。

REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成**客户端和服务端之间**的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。

但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。

![img](https://pic3.zhimg.com/80/45366c44f775abfd0ac3b43bccc1abc3_1440w.jpg?source=1940ef5c)



RPC 更侧重于动作。

[原文](https://developer.51cto.com/art/201906/597963.htm)

## HTTP 与 RPC的区别：

- RPC 可以基于tcp协议，也可以基于Http协议。
  - 可以自定义tcp协议或使用HTTP2，减小报文体积，提高传输效率。
  - RPC 可以基于 thrift 实现高效的二进制传输
  - 自带 负载均衡
- HTTP，是基于HTTP协议。
  - 如果基于 HTTP1.1 会有许多无用的内容。
  - 基于 json 来实现，比thrift 都耗时。
  - 需要使用 Nginx 实现负载均衡。

RPC主要用于公司内部的服务器调用，性能消耗低，传输效率高。服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。

## DNS协议用到了什么传输层协议？ **（一台新电脑如何获取到有效的网关地址）** 

从依赖关系的角度看，DNS既可以基于TCP，也可以基于UDP，常用的是UDP，服务器则使用知名端口53.



## 在浏览器中输入一个url，敲下回车之后发生的事情**（考虑DNS解析，负载均衡，建立连接等等）** 

- DNS 域名解析
- 建立TCP连接
- 发送Http 请求
- 服务器处理请求
- 返回相应结果
- 关闭TCP连接
- 浏览器解析HTML
- 浏览器布局渲染

## http的报文结构？TCP的？IP的？ 

HTTP 基于tcp/ip 通信协议来传递数据，简单高效，无状态，无连接，灵活。

## get与post的区别

get：数据会被附在URL之后（HTTP协议头中），在浏览器地址栏中会显示

post：数据会放在HTTP的包体head中，

## http协议的发展历程（1.0，1.1，2.0，3.0）



## 浏览器发生302跳转背后的逻辑？

浏览器在原请求地址的响应的 Location 域找到要跳转的URI 执行跳转。

## 交换机与路由器的区别：

交换机：在数据链路层，使用mac地址，确定转发地址。

路由器：在网络层，使用Ip地址，确定转发地址。

路由器的每个端口都是一个独立的广播域和冲突域，而交换机是只有一个广播域和端口数量的冲突域。





# 操作系统

[原文](https://blog.csdn.net/NuanShuTT/article/details/107908519)

1.虚拟内存解决了什么问题？**（分页，分段，段页的区别）** 

  2.进程间通信的七种方式**（实现原理，具体应用场景）** 

  3.死锁产生的必要条件？如何解决死锁的问题？ 

  4.linux的各种IO模型？**（重点掌握epoll，底层结构红黑树 + 链表，能够说出为什么在管理数百万连接的过程效率还好，以及ET模式和LT模式）** 

  5.可以学习一下shell编程 

  6.内核态和用户态的区别以及转换？**（什么情况会转化：中断，各种中断进行分类）** 

  7.linux底层的零拷贝技术（**经历4次 -》3次 -》2次拷贝的优化历程）** 

  8.操作系统大内核和微内核之间的区别以及各自的好处？ 

  9.僵尸进程和孤儿进程产生的原因以及解决方式？ 

  10.操作系统的各自调度方式

# Spring

### spring中Bean的生命周期（装配Bean的过程）：

- 实例化
- 设置属性值（将值和Bean的引用注入进Bean对应的属性中）
- 如果实现了 BeanNameAware 接口，调用 setBeanName设置Bean的ID或者Name
- 如果实现了 BeanFactoryAware 接口，调用 setBeanFactory 设置 beanFactory
- 如果实现了 applicationContextAware 接口，调用 setApplicationContext 设置 applicationContext
- 调用 BeanPostProcessor 的预先初始化方法。
- 调用 InitializingBean 的 afterPropertiesSet 方法。
- 调用 init-method 方法
- 调用 BeanPostProcessor 的后初始化方法。
- 调用 DisposableBean 的 destroy() 方法
- 调用定制的 destroy-method 方法。

### SpringMVC处理请求的流程：

- 第一站到达DispatcherServlet ，它去查询 处理器映射
- 处理器映射，根据URL的信息返回给 DispatcherServlet 对应的 Handler
- DispatcherServlet 将请求携带的信息 ，交给处理器处理。
- 控制器完成相依的逻辑处理后，返回给 DispatcherServlet 一个 ModelAndView
- DispatcherServlet 调用视图解析器，将其转换为 真正的视图 返回给客户端。

### AOP解决了什么问题？怎么实现？

AOP 面向切面编程，是对面向对象编程的一个补充

利用一种横切技术，将公共行为封装到一个可重用的模块中，称其为 切面。

实现：使用代理技术

- 采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行。
- 采用静态织入的方式，引入特定的语法创建 切面

使用场景：

- Authentication 权限
- Caching 缓存
- 事务
- 。。。。



- `织入`是把`切面应用到目标对象`并`创建新的代理对象`的过程。切面在指定的连接点被织入到目标对象中。

### Spring如何在运行时通知对象

通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。



### Spring事务的传播属性是怎么回事？它会影响什么？

- require：有事务就加入，没有就创建一个事务。
- support：支持当前事务，没有就非事务运行
- mandatory：支持当前事务，没有就报异常
- require new：有没有事务都新建一个事务
- not support：以非事务方式运行，有事务就挂起
- never：以非事务的方式运行，有事务就报异常
- nested：如果当前存在事务就在嵌套事务内运行，没有事务采用 require的策略。

### 隔离级别：5个

- 采用数据库的默认隔离级别。

### Spring中BeanFactory和FactoryBean有什么区别？

- 表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是 IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 
- 以Bean结尾，表示它是⼀一个Bean，不不同于普通Bean的是：它是实现了了FactoryBean接⼝口的Bean，根据该 Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽而不不是FactoryBean本身

### Spring框架中IOC的原理是什么？

IOC：控制反转，控制权 由应用代码中转到了外部容器，控制权的转移是所谓反转。就是由Spring来控制对象的生命周期和对象之间的关系；

IOC控制反转：是一种将对象交给容器去控制的设计思想，松耦合，方便单元测试，增加功能重用性；

所谓**依赖注入**，即组件之间的依赖关系 由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。  

说控制对象⽣生存周期的不不再是引⽤用它的对象，⽽而是spring。对于某个具体的对象⽽而⾔言，以前是它控制其他对 象，现在是所有对象都被spring控制，所以这叫控制反转。 

依赖注入的思想是**通过反射机制实现**的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中 的类属性注入到类中。 

 **IoC的优点：**降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。 

### Spring 的依赖注入有哪几种方式？

- 构造方法注入：一般是强制依赖
- set方法注入：可选依赖

### 用Spring如何实现一个切面？

- @Aspect 
- @Pointcut
- @Around

### Spring如何实现数据库事务？

- 使用@Transactional注解或在配置文件里面配置

### Spring加载次序Classloader

1. 先构造函数—>然后是bean的set方法注入—>InitializingBean的afterPropertiesSet方法—>init-method⽅方法

### springboot的启动过程：

1. 通过 SpringFactoriesLoader加载 META-INF/spring.factories⽂文件，获取并创建 SpringApplicationRunListener对象 
2.  然后由 SpringApplicationRunListener来发出 starting 消息
3. 创建参数，并配置当前 SpringBoot 应⽤用将要使⽤用的 Environment 
4.  完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息 
5. 创建 ApplicationContext 
6. 初始化 ApplicationContext，并设置 Environment，加载相关配置等 
7. 由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤用使⽤用的 ApplicationContext已准 备OK 
8.  将各种 beans 装载⼊入 ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知 SpringBoot 应⽤用使⽤用的 ApplicationContext已装填OK 
9. refresh ApplicationContext，完成IoC容器器可⽤用的后⼀一步 
10. 由 SpringApplicationRunListener来发出 started 消息 
11. 完成终的程序的启动 
12. 由 SpringApplicationRunListener来发出 running 消息，告知程序已运行起来了了 

###  spring事件的实现原理，写出常用的几个事件。 

事件机制：Spring中的事件机制是一个**观察者模式**的实现.观察者模式就是一个目标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。 

spring默认存在的事件：

- ContextStartedEvent：开始时触发事件
- ContextStoppedEvent：停止时触发事件
- ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件
- ContextClosedEvent：ApplicationContext 关闭后触发的事件

RequestHandledEvent：请求处理事件，在web 应用中，当一个 http 结束请求触发该事件



### BeanFactory 和 ApplicationContext有什么区别？

- ApplicationContext是BeanFactory的子接口。
- BeanFactory  采用的是延时加载，只有在第一次调用时才能发现异常
- ApplicationContext 是启动时全部加载，有利于发现配置错误。
- BeanFactory 是Spring里面最底层的接口，包含了各种**Bean的定义**，**读取bean配置文档**，**管理bean的加载、实例化，**控制**bean的生命周期**，维护bean之间的依赖关系。
- ApplicationContext 是不仅具有BeanFactory的功能，还提供了更完整的框架功能，如同时加载多个配置文件，支持国际化，多个上下文。

### ApplicationContext通常的实现是什么？

- FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。
- ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。
- WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。

### 单例bean线程安全吗？

### Spring如何处理线程并发问题？

在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。

### 自动装配有哪些方式：

- no：没有自动装配，需要手动引用 bean 进行装配。
- by Type ：根据类型注入对象依赖项
- by Name：根据 bean 的名称注入对象依赖项
- constructor：利用构造函数进行装配，并且构造函数的参数也是通过 byType 进行装配。

### 使用 @Autowired 注解自动装配的过程是怎样的？

开启注解扫描，当容器扫描到 @Autowired ，就看看容器中是否有对应的bean

- 当有一个时，会自动装配
- 当有多个时，需要解决歧义性 使用 @Qualifier 注解。
- 当没有时，看看是否设置了 required=false ，否则报错

### @RequestMapping 注解有什么用

用于处理 Http 请求。

RequestMapping注解有六个属性，下面我们把她分成三类进行说明。

- value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
- method：指定请求的method类型， GET、POST、PUT、DELETE等；
- consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；
- produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；
- params： 指定request中必须包含某些参数值是，才让该方法处理。
- headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。

### Spring如何解决循环依赖

什么是循坏依赖，即**循环引用**，两个或多个bean相互引用，最终形成一个环。

**循环调用**是方法之间的环调用。循环调用无法解决，除非有终结条件，否则就是死循环，最终导致内存溢出错误。

**无法解决通过构造器注入构成的循环依赖**，只能抛出BeanCurrentylyInCreationException异常表示循环依赖。

Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean表示符在创建过程中将一直保持在这个池中，因此，如果在创建bean过程中发现自己已经在“当前创建bean池”中，将抛出BeanCurrentylyInCreationException异常，表示循环依赖；对于创建完毕的bean，将从“当前创建bean池”中清除掉。

setter循环依赖的解决

Spring是先将Bean对象实例化【依赖无参构造函数】--->再设置对象属性的。 这就不会报错了：

Spring先用构造器实例化Bean对象----->将实例化结束的对象放到一个Map中，并且Spring提供获取这个未设置属性的实例化对象的引用方法。结合我们的实例来看，，当Spring实例化了StudentA、StudentB、StudentC后，紧接着会去设置对象的属性，此时StudentA依赖StudentB，就会去Map中取出存在里面的单例StudentB对象，以此类推，不会出来循环的问题喽。

Spring为了解决单例的循环依赖问题，使用了**三级缓存**。

- 一级缓存：singletonObjects，全是完整的bean
- 二级缓存：earlySingletonObjects
- 三级缓存：singletonFactories 

Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，

为何使用三级缓存而不是二级缓存？

使用三级缓存而非二级缓存并不是因为只有三级缓存才能解决循环引用问题，其实二级缓存同样也能很好解决循环引用问题。使用三级而非二级缓存并非出于IOC的考虑，而是出于AOP的考虑，即若使用二级缓存，在AOP情形下，注入到其他bean的，不是最终的代理对象，而是原始对象。[原文](https://my.oschina.net/u/4340310/blog/4332450)

### Spring启动流程



# 设计模式



# Mybatis

# Redis

### 如何解决高并发减库存问题 

消息队列，异步处理，减库存加锁。

### redis 的数据结构

### redis为什么快？（io模型 + 基于内存 + 线程模型）



# Git

# Linux

### Linux统计文件某个字符出现的次数

- 单个字符串 ：

```bash
grep -o 目标字符串 文件名 | wc -l
```

若查找多个字符串，目标字符串使用 `|` 隔开。

### linux查看一个文件多少行，如何创建文件（说命令）

```bash
wc -l a.txt
```





