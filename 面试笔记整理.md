# Java基础

## 基础知识点

###  1. 接口与抽象类区别 

都不能实例化

接口：所有的方法都是抽象的 public 方法，允许多继承。JDK1.8 可以实现默认方法和静态方法，通过 default 和 static 关键字。

抽象类：只能单继承，里面可以有非抽象方法，允许 private 和 protected 修饰方法。

### 内存溢出是怎么回事？举个例子。

 内存溢出(out of memory)，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。

内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存,迟早会被占光。 

 内存溢出可能的原因:

- 程序中存在死循环
- 静态变量量和静态⽅方法太多了了
- 内存泄露
- 大对象过多
- 空间给的太小

###  Java有⾃自⼰己的内存回收机制，但为什什么还存在内存泄漏漏的问题呢？ 

### ==和equals的区别

- ==是运算符，而equals是Object的基本⽅方法，
- ==用于基本类型的数据的比较，或者是比较两个对象的引用是否相同，
- equals用于比较两个对象的值是否相等，例如字符串的比较。 

### hashCode方法的作用

- hashCode是 ⽤用来在散列列存储结构中确定对象的存储地址的；
- 如果两个对象的 equals 相等，那么他们的hashcode值一定要相等。
- 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法

###  hash冲突：

两个或两个以上 的值hash计算的结果有相同的，造成冲突。

解决办法：

1. 开放地址法：插⼊入元素时，如果发⽣生冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下⼀一个空 槽，并将该元素放⼊入该槽中（会导致相同hash值的元素挨在⼀一起和其他hash值对应的槽被占⽤用）。
2. 链地址法：现⾏行行探测法的基本思想是将所有哈希地址为i的元素构成⼀一个称为同义词链的单链表，并将单链表的头指针 存在哈希表的第i个单元中，因⽽而查找、插⼊入和删除主要在同义词链中进⾏行行。链地址法适⽤用于经常进⾏行行插⼊入和删除的情况。
3. 在散列列(双/多重散列列)：当发⽣生冲突时，使⽤用第⼆二个、第三个、哈希函数计算地址，直到⽆无冲突时。缺点：计算时间增 加。
4. 建⽴立⼀一个公共溢出区：假设哈希函数的值域为[0,m-1],则设向量量HashTable[0..m-1]为基本表，另外设⽴立存储空间向量量 OverTable[0..v]⽤用以存储发⽣生冲突的记录。

### 一致性hash：？？？？？

1. 分布式系统中常用算法。设计⽬目的是为了了解决因特⽹网中的热点(hot spot)问题。解决了了P2P环境最为关键问 题—如何在动态⽹网络拓拓扑中分布存储和路路由；
2. 一致性hash算法引⼊入虚拟节点机制，解决服务节点少时数据倾斜问题(即对每⼀一个服务节点计算多个哈希，每个计算结果位置都 放置⼀一个此服务节点，称为虚拟节点。)

在 memcached 中，用于进行数据存储结点的选择。

⼀一致性hash算法是对我们要存储数 据的服务器器进⾏行行hash计算，进⽽而确认每个key的存储位置。

选择具体的机器器节点不不在只依赖需要 缓存数据的key的hash本身了了，⽽而是机器器节点本身也进⾏行行了了hash运算。 

具体做法：如果有⼀一个写⼊入缓存的请求，其中Key值为K，计算器器hash值Hash(K)， Hash(K) 对应于图 – 1环中的某⼀一个点，如果 该点对应没有映射到具体的某⼀一个机器器节点，那么顺时针查找，直到第⼀一次找到有映射机器器的节点，该节点就是确定的⽬目标节点，如果超过了了 2^32仍然找不不到节点，则命中第⼀一个机器器节点。⽐比如 Hash(K) 的值介于A~B之间，那么命中的机器器节点应该是B节点（如上图 ）。 

### NIO、BIO、AIO

#### io多路复用

###  java中⼀一个字符占多少个字节？int，long，double占多少个字节？ 

- 1字节： byte , boolean 
- 2字节： short , char 
- 4字节： int , float 
- 8字节： long , double 

### final/finaly/finalize区别？

- final是定义类、⽅方法、字段的修饰符，表示类不不可被继承，⽅方法不不能被重写，字段值不不能被修改 
  - 声明变量时直接赋值，也可以在构造函数中复制
  - 若是 static final 那么就是 只能在申明时 赋值。
- finally是异常处理理机制的关键字，表示后执⾏行行
- finalize是Object的⼀一个⽅方法，在对象被虚拟机回收时会判断是否执⾏行行该⽅方法，当对象没有覆盖finalize⽅方法，或者finalize⽅方法 已经被虚拟机调⽤用过，虚拟机将这两种情况都视为“没有必要执⾏行行” 

### 为什什么⼀一般在public类final终态成员变量量申明时要加static?   

static对象存放在静态空间，不不会在运⾏行行时被释放，可以节省内存，类的多个对象同时引⽤用只有⼀一份,没有多份拷⻉贝

### Session/Cookie区别？

Session存储在服务器器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串

###  String/StringBuffer/StringBuilder的区别以及实现？ 

-  String、StringBuffer是线程安全的，StringBuilder不不是 
- StringBuffer线程安全但效率低，应该使⽤用在多线程情况下；
- StringBuilder线程不不安全，在单线程情况下效率⾼高；

###  什么是java序列列化，如何实现java序列列化（写⼀一个例例⼦子） 

序列列化作⽤用：对象保存(保存为⼀一组字节，只保存对象的成员变量量)；当使⽤用RMI(远程⽅方法调⽤用)，或者在⽹网络中传递对象 时，都会使⽤用对象序列列化；

原理理：将对象写⼊入流中,再从流中还原.ObjectOutPutStream 

对象中的成员对象也是可序列列化的,但可通过transient关键字标示不不序列列化 

通过序列列化进⾏行行深拷⻉贝,从流中还原对象 

serialVersionUID 主要是解决序列列化后与再反序列列化时有修改的不不兼容问题. 

###  静态对象

1. 在main⽅方法开始运⾏行行时需要注意static的先后顺序：静态变量量和静态代码块(按代码先后顺序)—-匿匿名块和成员变量量(按代码先 后顺序)—-构造函数—静态⽅方法(调⽤用时加载)
2. 先执⾏行行⽗父类的静态块,再执⾏行行⼦子类的静态块,再执⾏行行⽗父类的构造⽅方法,再执⾏行行⼦子类的构造⽅方法 1、静态块>构造⽅方法； 2、⽗父>⼦子

###  多态：

父类或接口引用指向子类或者实现该接口的类的对象。是运行时行为，不是编译时行为。

条件：有继承、有重写、要父类引用指向子类对象。

### 幂等处理：

[幂等](https://www.jianshu.com/p/cea3675a590b)：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的

- 查询操作是天然幂等
- 唯⼀一索引，防⽌止新增脏数据 
- token机制，防⽌止⻚页⾯面重复提交
- 悲观锁  for update 
- 乐观锁（通过版本号/时间戳实现， 通过条件限制where avai_amount-#subAmount# >= 0）
- 分布式锁 

















## 集合

### 常⽤用的集合类有哪些？⽐比如list如何排序？ 

主要分为三类，Map、Set、List 

- Map: HashMap、LinkedHashMap、TreeMap 
- Set：HashSet、LinkedHashSet、TreeSet 
- List: ArrayList、LinkedList 

```java
Collections.sort(list); // list 排序
```

### ArrayList和LinkedList内部实现大致是怎样的？他们之间的区别和优缺点？ 

ArrayList：是基于数组的存储结构，查找快，添加和删除比较慢，默认大小为 10，扩容是1.5倍，利用数组的复制。

LinkedList：是基于双向链表的存储接口，查找慢，添加和删除有优势，

### Hashmap实现原理理？如何保证HashMap线程安全

hashmap采用的是数组加链表（JDK7），采用数组加链表加红黑树（JDK8）

允许有空值，

![](D:\harlearn.github.io\图片\hashMap的put操作.PNG)

1. Jdk1.8以前是进⾏行行**四次扰动计算**，可能从速度功效各⽅方⾯面考虑，jdk1.8变成扰动⼀**一次**，低16位和⾼高16位进⾏行行异或计算。**取模的时** 候考虑取模运算的速度⽐比较慢，改⽤用**与操作优化效率**，很巧妙，hash table就没设计的这么好。 
2. JDK1.8⾥里里对hashmap⼤大的改变是引⼊入了了红⿊黑树，这⼀一点在hash不不均匀并且元素个数很多的情况时，对hashmap的性能提升⾮非 常⼤大。Hashmap的底层实现是使⽤用⼀一个entry数组存储，默认**初始⼤大⼩小16**，不不过jdk8换了了名字叫node，可能是因为引⼊入了了树，叫 node更更合适吧，Node⾥里里有next引⽤用指向下⼀一个节点，因为hashmap解决冲突的思路路是**拉链法。** 
3. 另外变化⽐比较⼤大的还有扩容机制，也就是resize⽅方法

###  jdk1.8中ConcurrentHashMap size⼤大于8时会转化成红⿊黑树，请问有什什么作⽤用，如果通过remove操作，size⼩小于8了了，会发⽣生什什 么？ 

put时如果链表size>=8并且table.length>=64，这时链表会转变成⼀一个红⿊黑树，但是remove不不会逆转。

### HashMap与HashTable的区别：

HashMap 不是线程安全的，Hashtable 是线程安全的

在单线程的情况下 HashMap 效率更加的高

### 













## 多线程

### 1. 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执 行？ 

无非就是在t2线程里面申明t1.join(),在t3线程里面t2.join();这样就可以了

```java
public class threadDemo7 {
	public static void main(String[] args) throws InterruptedException {
		xiancheng1 x1=new xiancheng1();
		xiancheng2 x2=new xiancheng2();
		xiancheng3 x3=new xiancheng3();
		Thread thread1 = new Thread(x1);
		thread1.start();
		Thread thread2 = new Thread(x2);
		thread1.join(); 
		thread2.start();
		Thread thread3 = new Thread(x3);
		thread2.join();
		thread3.start();
	}
}
```

或者

```java

public class Demo2 {

    private static volatile  int nextPrintWho = 1;

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException {
        ReentrantLock lock = new ReentrantLock();
        Condition conditionA = lock.newCondition();
        Condition conditionB = lock.newCondition();
        Condition conditionC = lock.newCondition();

        Runnable runnableA = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 1) {
                try {
                    conditionA.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 2;
            println(Thread.currentThread().getName());
            try {
                conditionB.signal();// 通知 B
             }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        Runnable runnableB = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 2) {
                try {
                    conditionB.await();// B等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 3;
            println(Thread.currentThread().getName());
            try {
                conditionC.signal(); // 通知C
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };


        Runnable runnableC = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 3) {
                try {
                    conditionC.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 1;
            println(Thread.currentThread().getName());
            try {
                conditionA.signal();// 通知A
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        for(int i=0; i<5; i++) {
            new Thread(runnableA,"A").start();
            new Thread(runnableB,"B").start();
            new Thread(runnableC,"C").start();
        }


    }

    private static void println(Object object) {
        System.out.println(object);
    }

}
```

### 2. 在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允 许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？ 

lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写 像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。

### 3. 在 java 中 wait 和 sleep 方法的不同？ 

最大的不同是在等待时 wait 会释放 锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。 

###  4. 用 Java 实现阻塞队列。

如果他用 wait()和 notify()方法来实现阻塞队列，

### 5. 用 Java 写代码来解决生产者——消费者问题。 

用阻塞队列实现 的方法

### 6. 用 Java 编程一个会导致死锁的程序，你将怎么解决？ 

### 7.什么是原子操作，Java 中的原子操作是什么

### Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什 么不同？

### 你将如何使用 threaddump？你将如何分析 Thread dump

在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志

### 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法

当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。 但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码

### Java 中你怎样唤醒一个阻塞的线程？ 

如果线程遇到了 IO 阻塞，我并 且不认为有一种方法可以中止线程。如果线程因为调用 wait()、sleep()、或者 join()方法而 导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。

### 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？ 

### 什么是不可变对象，它对写并发应用有什么帮助

这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变 的。 

### 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？ 

多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题 是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于 实际应用的 Java 线程问题。 







## 反射

### java反射机制

可以在运⾏行行时判断⼀一个对象所属的类，构造⼀一个类的对象，判断类具有的成员变量量和⽅方法，调⽤用1个对象的⽅方法。 

4个关键的类：Class，Constructor，Field，Method。    

- getConstructor获得构造函数/getDeclardConstructor； 
- getField/getFields/getDeclardFields获得类所⽣生命的所有字段；
- getMethod/getMethods/getDeclardMethod获得类声明的所有⽅方法，

正 常⽅方法是⼀一个类创建对象，⽽而反射是1个对象找到1个类。 

### 获得Class对象的⽅方式 

1. 静态类的.class语法：GuideUtil.class 
2. 普通类对象的getClass()⽅方法：new Test().getClass() 
3. 通过Class对象的forName()⽅方法：Class.forName(“com.zhenai.modules.guide.utils.GuideUtil"); 
4. 对于包装类,可以通过.TYPE语法⽅方式：Integer.TYPE 

## Jvm

###  jvm内存结构？为什什么需要GC？ 

- 方法区：类型的常量池，字段，方法信息，方法字节码。
- 堆：应用系统的对象
- 程序计数器：记录代码执行的位置
- 虚拟机栈：栈帧，保存一个方法的局部变量，操作数，常量池指针
- 本地方法栈：和 虚拟机栈类似，针对的 Native 修饰的方法

垃圾回收：垃圾回收可以有效的防⽌止内存泄漏漏，有效的使⽤用可以使⽤用的内存

### jvm内存模型：

- 每⼀一个线程有⼀一个⼯工作内存，和主存独⽴立；
- ⼯工作内存存放主存中变量量的值的拷⻉贝；
- 对于普通变量量，⼀一个线程中更更新的值，不不能⻢马上反应在其他变量量中；如果需要在其他线程中⽴立即可⻅见，需要使⽤用volatile关键字； 

**可⻅见性：**⼀一个线程修改了了变量量，其他线程可以⽴立即知道。

- volatile； 
- synchronized（unlock之前，写变量量值回主存）；
- final（⼀一旦初始化完成，其他线程可⻅见）。 

### java四引⽤用：

强引用：在什么情况下，都不会被垃圾收集器回收。

软引用：在内存不够时，会被回收

弱引用：在每一次垃圾回收时，就会被回收掉

虚引用：任何情况都有可能被垃圾收集器回收，用来跟踪对象被垃圾收集器回收的活动，会给系统一个通知

### GC算法分类

**标记清除：**

先标记需要被清除的对象，然后统一清除所有被清除的对象。

缺点：有大量被清除对象时，效率低。内存碎片化严重

**标记复制：**

将内存分为两块，只使用其中一块，每次将存活的对象复制到未使用的那一块内存中，清除所有已经使用的内存。

缺点：当存活对象较高时，效率低。

**标记整理：**

先标记，然后将存活对象复制到内存的一端，然后，清除边界外所有的空间。

适合用户存活对象多的场景。

优点：解决了碎片化问题。结局了存活率高时，复制算法效率低的问题。

**分代算法：**

大部分对象都是朝生夕灭的

经历越多次的垃圾回收，月不容易被回收。

标记整理算法适合老年代，标记复制算法适合新生代。

### MinorGC & FullGC

1. Minor GC通常发⽣生在新⽣生代的Eden区，在这个区的对象⽣生存期短，往往发⽣生GC的频率较⾼高，回收速度⽐比较快，⼀一般采⽤用复制-回 收算法
2. Full GC/Major GC 发⽣生在⽼老老年年代，⼀一般情况下，触发⽼老老年年代GC的时候不不会触发Minor GC，所采⽤用的是标记-清除算法。 

### 垃圾收集器器：

- CMS收集器器，基于标记清理理；
- G1收集器器(JDK)：整体上是基于标记清理理，局部采⽤用复制； 

综上：新⽣生代基本采⽤用复制算法，⽼老老年年代采⽤用标记整理理算法。cms采⽤用标记清理理

### 哪些情况下对象会进⼊入⽼老老年年代？

- 当达到年年龄阈值（默认为15岁）会直接进⼊入⽼老老年年代
- ⼤大对象直接进⼊入⽼老老年年代； 
- 需要⽼老老年年代进⾏行行分配 担保，让survivor⽆无法容纳的对象直接进⼊入⽼老老年年代； 
- 如果在Survivor空间中相同年年龄所有对象⼤大⼩小的总和⼤大于Survivor空间的⼀一半，年年龄⼤大于或等于该年年龄的对象就可以直接进⼊入年年⽼老老 代。 

###  java堆溢出（heap）：

-  Java堆内存主要⽤用来存放运⾏行行过程中所以的对象，该区域OOM异常⼀一般会有如下错误信息： OutofMemoryError
- 此类错误⼀一般通过Eclipse Memory Analyzer分析OOM时dump的内存快照就能分析出来，到底是由于程序原因导致的内存泄 露露，还是由于没有估计好JVM内存的⼤大⼩小⽽而导致的内存溢出。 

### 栈溢出（stack）：

- 栈⽤用来存储线程的局部变量量表、操作数栈、动态链接、⽅方法出⼝口等信息。如果请求栈的深度不不⾜足时抛出的错误会包含类似下⾯面 的信息： java.lang.StackOverflowError。
-  另外，由于每个线程占的内存⼤大概为1M，因此线程的创建也需要内存空间。
-  可能原因
  -  递归：递归⾥里里⽤用到的局部变量量存储在堆栈中，堆栈的访问效率⾼高，速度快，但空间有限，递归太多变量量需要⼀一直⼊入栈⽽而 不不出栈，导致需要的内存空间⼤大于堆栈的空间，栈空间是2M，堆空间内存空间。 

###  对象流转流程（新⽣生代复制算法，可以减少内存碎⽚片）：

- 对象A被new出来之后，是被存放在Eden（伊甸园）区的。 
- 当发⽣生⼀一次GC后，Eden区存活下来的对象A会被复制到s1区，s0中存活的对象也会被复制到s1中。 
-  GC会清空Eden和s0中存储的所有对象； 
- 交换s0和s1的⻆角⾊色；
- 重复上⾯面的步骤。





### java类加载机制：

将字节码文件加载到内存中

过程：

- 加载：根据全限定名加载二进制流，将静态存储结构转化为方法区运行时数据结构，并生成以改变此类的 Class 对象。
- 验证：验证 文件验证，元数据验证，字节码验证，符号引用验证
- 准备：为类属性分配内存，并设置类属性的初始值，（Static 会被设置默认值，static final 被设置为给予的值）
- 解析：将常量池中的符号引用替换成直接引用。
- 初始化：初始化阶段，就是执行类构造器 `<clint>()` 方法的过程。
- 使用：
- 卸载：

### 类加载器：

- BootStrap（启动类加载器），最顶层的类加载器，主要加载 jdk 核心库lib下面
- Extension（扩展类加载器），用于加载lib/ext目录下面的jar 包
- application（应用程序加载器），加载 classpath 的所有类。
- 自定义类加载器

### 双亲委派机制：

当⼀一个ClassLoader实例例需要加载某个类时，它会试图亲⾃自搜索某个类之前，先把这个任务委托给它的⽗父类加载器器，这 个过程是由上⾄至下依次检查的，⾸首先由顶层的类加载器器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给 Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进⾏行行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的⽂文件系统或⽹网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出 ClassNotFoundException异常。

作用：避免重复加载；考虑安全因素，避免自定义的类去替代系统类，如String。

### jvm如何判定两个class是否相同

JVM在判定两个class是否相同时，不不仅要判断两个类名是否相同，⽽而且要判断是否由同⼀一个类加 载器器实例例加载的。只有两者同时满⾜足的情况下，JVM才认为这两个class是相同的。 

1. ⾃底向上检查类是否已经加载； 2. ⾃顶向下尝试加载类。

### 自定义类加载器

- 继承 ClassLoader
- 重写 父类的 findClass 方法

### 引起类加载的五个行为： 

- 遇到 new、putstatic、getstatic、invokestatic 这四条字节码指令。
- 反射调用时，
- 子类初始时，发现父类没有初始化，会触发父类的加载
- 主类，含有main的
- jdk7的动态语言支持

### java对象创建的时机，几种方式创建对象

- 使用反射
- clone
- 序列化
- new

### jvm 调优

#### 什么时间进行jvm 调优

1. 内存（老年代）持续上涨达到设置的最大内存值
2. Full GC 次数频率过高
3. GC 停顿时间过长。
4. 出现内存溢出
5. 应用中使用本地缓存且占用大量内存空间
6. 系统吞吐量与响应性能不高或下降

#### 调优原则：

先检查引用代码，其次考虑优化 JVM

- 减少创建对象的数量
- 减少全局变量和大对象

####  调优步骤

- 分析GC⽇日志及dump⽂文件，判断是否需要优化，确定瓶颈问题点； 
- 确定jvm调优量量化⽬目标； 
-  确定jvm调优参数（根据历史jvm参数来调整）；
-  调优⼀一台服务器器，对⽐比观察调优前后的差异； 
- 不不断的分析和调整，知道找到合适的jvm参数配置；
-  找到合适的参数，将这些参数应⽤用到所有服务器器，并进⾏行行后续跟踪。 



















# 数据库

## MySQL

### MySQL InnoDB、Mysaim的特点？ 

#### InnoDB：

1. ⽀支持事务处理理
2. 支持外键
3. 支持行锁
4. 不不⽀支持FULLTEXT类型的索引（在Mysql5.6已引⼊入） 
5. 不不保存表的具体⾏行行数，扫描表来计算有多少⾏行行 
6. 对于AUTO_INCREMENT类型的字段，必须包含只有该字段的索引
7. DELETE 表时，是⼀一⾏行行⼀一⾏行行的删除 
8. InnoDB 把数据和索引存放在表空间⾥⾯
9. 跨平台可直接拷贝使用

#### MyISAM：

1. 不支持事务
2. 表级锁
3. 不支持外键
4. 支持全文索引
5. 保存了表的具体行数
6. delete时， 先 drop 表，然后重建表
7. 表格可以被压缩

 选择：

如果系统读多，写少。对原子性要求低。那么MyISAM最好 的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。

如果系统读少，写多的时候，尤其是并发写⼊入⾼高的时候。 InnoDB就是⾸首选了了。

### 行锁，表锁；乐观锁，悲观锁

乐观锁：具体实现是给表增加⼀一个版本号的字 段，在执⾏行行update操作时⽐比较该版本号是否与当前数据库中版本号⼀一致，如⼀一致，更更新数据，反之拒绝。 

数据库锁机制可分为多种粒度的： 数据库，表，⻚⾯面，行，粒度越大并发处理能力就越差。





### 数据库隔离级别是什么？有什么作用？

- 读未提交：一个事务可以读取另一个事务未提交的数据，会有脏读，不可重复读，幻读。
- 读已提交：一个事务提交后，数据才能够被读取。不可重复读，幻读。
- 可重复度：一个事务内的查询都要是事务开始时刻一致，有幻读问题
- 序列化（串行化）：最高的代价，事务被处理为顺序执行。读和写都会阻塞，避免了幻读

### MySQL主备同步的基本原理理。 

1. master将改变记录到⼆二进制⽇日志(binary log)中（这些记录叫做⼆二进制⽇日志事件，binary log events，可以通过show binlog events进⾏行行查看）；
2. slave将master的binary log events拷⻉贝到它的中继日志(relay log)； 
3. slave重做中继⽇日志中的事件，将改变反映它⾃自⼰己的数据。

###  select * from table t where size > 10 group by size order by size的sql语句句执⾏行行顺序？ 

sql语句句执⾏行行顺序如下： where -> group by -> having -> select -> orderby









### SQL优化

#### 如何优化数据库性能（索引、分库分表、批置操作、分⻚页算法、升级硬盘SSD、业务优化、主从部署

- 选择合适的数据库引擎，合理使用索引
- 分页获取数据，只获得需要的字段。
- 优化业务逻辑，减少数据库IO
- 分库分表
- 部署主从数据库
- 升级硬件

#### SQL什么情况下不会使用索引（不包含，不等于，函数）

- select * 可能导致不不⾛走索引；
- 空值会导致不⾛索引，因为hashset不能存空值； 
- 索引列有函数运算，不走索引，可以在索引列建立一个函数的索引。 
- 隐式转换可能导致不走索引；
-  != 或者<>可能导致不⾛走索引；
- like '%liu' 百分号在前不走索引；
- not in, not exist不走索引；

#### mysql调优：

- 当只要一条数据时使用 `limit 1`；
- 尽量都要走索引
- delete 和 insert 会锁表

### innodb如何实现mysql的事务？

redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。

1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。

mysql脏页：
当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页；
内存数据写入磁盘后，内存页上的数据和磁盘页上的数据就一致了，我们称这个内存页为干净页。



# Spring

### spring中Bean的生命周期（装配Bean的过程）：

- 实例化
- 设置属性值（将值和Bean的引用注入进Bean对应的属性中）
- 如果实现了 BeanNameAware 接口，调用 setBeanName设置Bean的ID或者Name
- 如果实现了 BeanFactoryAware 接口，调用 setBeanFactory 设置 beanFactory
- 如果实现了 applicationContextAware 接口，调用 setApplicationContext 设置 applicationContext
- 调用 BeanPostProcessor 的预先初始化方法。
- 调用 InitializingBean 的 afterPropertiesSet 方法。
- 调用 init-method 方法
- 调用 BeanPostProcessor 的后初始化方法。
- 调用 DisposableBean 的 destroy() 方法
- 调用定制的 destroy-method 方法。

### SpringMVC处理请求的流程：

- 第一站到达DispatcherServlet ，它去查询 处理器映射
- 处理器映射，根据URL的信息返回给 DispatcherServlet 对应的 Handler
- DispatcherServlet 将请求携带的信息 ，交给处理器处理。
- 控制器完成相依的逻辑处理后，返回给 DispatcherServlet 一个 ModelAndView
- DispatcherServlet 调用视图解析器，将其转换为 真正的视图 返回给客户端。

### AOP解决了什么问题？怎么实现？

AOP 面向切面编程，是对面向对象编程的一个补充

利用一种横切技术，将公共行为封装到一个可重用的模块中，称其为 切面。

实现：使用代理技术

- 采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行。
- 采用静态织入的方式，引入特定的语法创建 切面

使用场景：

- Authentication 权限
- Caching 缓存
- 事务
- 。。。。

### Spring事务的传播属性是怎么回事？它会影响什么？

- require：有事务就加入，没有就创建一个事务。
- support：支持当前事务，没有就非事务运行
- mandatory：支持当前事务，没有就报异常
- require new：有没有事务都新建一个事务
- not support：以非事务方式运行，有事务就挂起
- never：以非事务的方式运行，有事务就报异常
- nested：如果当前存在事务就在嵌套事务内运行，没有事务采用 require的策略。

### 隔离级别：5个

- 采用数据库的默认隔离级别。

### Spring中BeanFactory和FactoryBean有什么区别？

- 表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是 IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 
- 以Bean结尾，表示它是⼀一个Bean，不不同于普通Bean的是：它是实现了了FactoryBean接⼝口的Bean，根据该 Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，⽽而不不是FactoryBean本身

### Spring框架中IOC的原理是什么？

IOC：控制反转，控制权 由应用代码中转到了外部容器，控制权的转移是所谓反转。就是由Spring来控制对象的生命周期和对象之间的关系；

IOC控制反转：是一种将对象交给容器去控制的设计思想，松耦合，方便单元测试，增加功能重用性；

所谓**依赖注入**，即组件之间的依赖关系 由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。  

说控制对象⽣生存周期的不不再是引⽤用它的对象，⽽而是spring。对于某个具体的对象⽽而⾔言，以前是它控制其他对 象，现在是所有对象都被spring控制，所以这叫控制反转。 

依赖注入的思想是**通过反射机制实现**的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中 的类属性注入到类中。 

 **IoC的优点：**降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。 

### Spring 的依赖注入有哪几种方式？

- 构造方法注入：
- set方法注入：

### 用Spring如何实现一个切面？

- @Aspect 
- @Pointcut
- @Around

### Spring如何实现数据库事务？

- 使用@Transactional注解或在配置文件里面配置

### Spring加载次序Classloader

1. 先构造函数—>然后是bean的set方法注入—>InitializingBean的afterPropertiesSet方法—>init-method⽅方法

### springboot的启动过程：

1. 通过 SpringFactoriesLoader加载 META-INF/spring.factories⽂文件，获取并创建 SpringApplicationRunListener对象 
2.  然后由 SpringApplicationRunListener来发出 starting 消息
3. 创建参数，并配置当前 SpringBoot 应⽤用将要使⽤用的 Environment 
4.  完成之后，依然由 SpringApplicationRunListener来发出 environmentPrepared 消息 
5. 创建 ApplicationContext 
6. 初始化 ApplicationContext，并设置 Environment，加载相关配置等 
7. 由 SpringApplicationRunListener来发出 contextPrepared消息，告知SpringBoot 应⽤用使⽤用的 ApplicationContext已准 备OK 
8.  将各种 beans 装载⼊入 ApplicationContext，继续由 SpringApplicationRunListener来发出 contextLoaded 消息，告知 SpringBoot 应⽤用使⽤用的 ApplicationContext已装填OK 
9. refresh ApplicationContext，完成IoC容器器可⽤用的后⼀一步 
10. 由 SpringApplicationRunListener来发出 started 消息 
11. 完成终的程序的启动 
12. 由 SpringApplicationRunListener来发出 running 消息，告知程序已运行起来了了 

###  spring事件的实现原理，写出常用的几个事件。 

事件机制：Spring中的事件机制是一个**观察者模式**的实现.观察者模式就是一个目标对象管理所有相依于它的观察者对象,并且在它本身的状态改变时主动发出通知.Spring的事件由ApplicationContext发布。 

spring默认存在的事件：

- ContextStartedEvent：开始时触发事件
- ContextStoppedEvent：停止时触发事件
- ContextRefreshedEvent：ApplicationContext初始化或刷新完成后触发的事件
- ContextClosedEvent：ApplicationContext 关闭后触发的事件



























# Mybatis

# Redis

### 如何解决⾼高并发减库存问题 

消息队列，异步处理，减库存加锁。

# Git

# Linux



