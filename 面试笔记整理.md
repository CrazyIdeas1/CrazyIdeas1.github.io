# Java基础

## 基础知识点

###  1. 接口与抽象类区别 

都不能实例化

接口：所有的方法都是抽象的 public 方法，允许多继承。JDK1.8 可以实现默认方法和静态方法，通过 default 和 static 关键字。

抽象类：只能单继承，里面可以有非抽象方法，允许 private 和 protected 修饰方法。

### 内存溢出是怎么回事？举个例子。

 内存溢出(out of memory)，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。

内存泄漏 memory leak，是指程序在申请内存后，⽆法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存,迟早会被占光。 

 内存溢出可能的原因:

- 程序中存在死循环
- 静态变量量和静态⽅方法太多了了
- 内存泄露
- 大对象过多
- 空间给的太小

###  Java有⾃自⼰己的内存回收机制，但为什什么还存在内存泄漏漏的问题呢？ 

### ==和equals的区别

- ==是运算符，而equals是Object的基本⽅方法，
- ==用于基本类型的数据的比较，或者是比较两个对象的引用是否相同，
- equals用于比较两个对象的值是否相等，例如字符串的比较。 

### hashCode方法的作用

- hashCode是 ⽤用来在散列列存储结构中确定对象的存储地址的；
- 如果两个对象的 equals 相等，那么他们的hashcode值一定要相等。
- 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法

### NIO、BIO、AIO

#### io多路复用

###  java中⼀一个字符占多少个字节？int，long，double占多少个字节？ 

- 1字节： byte , boolean 
- 2字节： short , char 
- 4字节： int , float 
- 8字节： long , double 

### final/finaly/finalize区别？

- final是定义类、⽅方法、字段的修饰符，表示类不不可被继承，⽅方法不不能被重写，字段值不不能被修改 
- finally是异常处理理机制的关键字，表示后执⾏行行
- finalize是Object的⼀一个⽅方法，在对象被虚拟机回收时会判断是否执⾏行行该⽅方法，当对象没有覆盖finalize⽅方法，或者finalize⽅方法 已经被虚拟机调⽤用过，虚拟机将这两种情况都视为“没有必要执⾏行行” 

### Session/Cookie区别？

Session存储在服务器器端，类型可以是任意的Java对象，Cookie存储在客户端，类型只能为字符串

###  String/StringBuffer/StringBuilder的区别以及实现？ 

-  String、StringBuffer是线程安全的，StringBuilder不不是 
- StringBuffer线程安全但效率低，应该使⽤用在多线程情况下；
- StringBuilder线程不不安全，在单线程情况下效率⾼高；

###  什么是java序列列化，如何实现java序列列化（写⼀一个例例⼦子） 

序列列化作⽤用：对象保存(保存为⼀一组字节，只保存对象的成员变量量)；当使⽤用RMI(远程⽅方法调⽤用)，或者在⽹网络中传递对象 时，都会使⽤用对象序列列化；

原理理：将对象写⼊入流中,再从流中还原.ObjectOutPutStream 

对象中的成员对象也是可序列列化的,但可通过transient关键字标示不不序列列化 

通过序列列化进⾏行行深拷⻉贝,从流中还原对象 

serialVersionUID 主要是解决序列列化后与再反序列列化时有修改的不不兼容问题. 





















## 集合

### 常⽤用的集合类有哪些？⽐比如list如何排序？ 

主要分为三类，Map、Set、List 

- Map: HashMap、LinkedHashMap、TreeMap 
- Set：HashSet、LinkedHashSet、TreeSet 
- List: ArrayList、LinkedList 

```java
Collections.sort(list); // list 排序
```

### ArrayList和LinkedList内部实现大致是怎样的？他们之间的区别和优缺点？ 

ArrayList：是基于数组的存储结构，查找快，添加和删除比较慢，默认大小为 10，扩容是1.5倍，利用数组的复制。

LinkedList：是基于双向链表的存储接口，查找慢，添加和删除有优势，

### Hashmap实现原理理？如何保证HashMap线程安全

hashmap采用的是数组加链表（JDK7），采用数组加链表加红黑树（JDK8）

允许有空值，

![](D:\harlearn.github.io\图片\hashMap的put操作.PNG)















## 多线程

### 1. 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执 行？ 

无非就是在t2线程里面申明t1.join(),在t3线程里面t2.join();这样就可以了

```java
public class threadDemo7 {
	public static void main(String[] args) throws InterruptedException {
		xiancheng1 x1=new xiancheng1();
		xiancheng2 x2=new xiancheng2();
		xiancheng3 x3=new xiancheng3();
		Thread thread1 = new Thread(x1);
		thread1.start();
		Thread thread2 = new Thread(x2);
		thread1.join(); 
		thread2.start();
		Thread thread3 = new Thread(x3);
		thread2.join();
		thread3.start();
	}
}
```

或者

```java

public class Demo2 {

    private static volatile  int nextPrintWho = 1;

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException {
        ReentrantLock lock = new ReentrantLock();
        Condition conditionA = lock.newCondition();
        Condition conditionB = lock.newCondition();
        Condition conditionC = lock.newCondition();

        Runnable runnableA = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 1) {
                try {
                    conditionA.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 2;
            println(Thread.currentThread().getName());
            try {
                conditionB.signal();// 通知 B
             }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        Runnable runnableB = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 2) {
                try {
                    conditionB.await();// B等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 3;
            println(Thread.currentThread().getName());
            try {
                conditionC.signal(); // 通知C
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };


        Runnable runnableC = ()-> {
            lock.lock();
            while (Demo2.nextPrintWho != 3) {
                try {
                    conditionC.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Demo2.nextPrintWho = 1;
            println(Thread.currentThread().getName());
            try {
                conditionA.signal();// 通知A
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        };

        for(int i=0; i<5; i++) {
            new Thread(runnableA,"A").start();
            new Thread(runnableB,"B").start();
            new Thread(runnableC,"C").start();
        }


    }

    private static void println(Object object) {
        System.out.println(object);
    }

}
```

### 2. 在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允 许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？ 

lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写 像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。

### 3. 在 java 中 wait 和 sleep 方法的不同？ 

最大的不同是在等待时 wait 会释放 锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。 

###  4. 用 Java 实现阻塞队列。

如果他用 wait()和 notify()方法来实现阻塞队列，

### 5. 用 Java 写代码来解决生产者——消费者问题。 

用阻塞队列实现 的方法

### 6. 用 Java 编程一个会导致死锁的程序，你将怎么解决？ 

### 7.什么是原子操作，Java 中的原子操作是什么

### Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什 么不同？

### 你将如何使用 threaddump？你将如何分析 Thread dump

在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志

### 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法

当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。 但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码

### Java 中你怎样唤醒一个阻塞的线程？ 

如果线程遇到了 IO 阻塞，我并 且不认为有一种方法可以中止线程。如果线程因为调用 wait()、sleep()、或者 join()方法而 导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。

### 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？ 

### 什么是不可变对象，它对写并发应用有什么帮助

这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变 的。 

### 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？ 

多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题 是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于 实际应用的 Java 线程问题。 







## 反射

## Jvm

###  jvm内存结构？为什什么需要GC？ 

- 方法区：
- 堆
- 程序计数器
- 虚拟机栈
- 本地方法栈

垃圾回收：垃圾回收可以有效的防⽌止内存泄漏漏，有效的使⽤用可以使⽤用的内存







# 数据库

## MySQL

### SQL优化

# Spring

# Mybatis

# Redis

# Git

# Linux



